## 4. 变量 作用域与内存

### 原始值与引用值

ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值. `原始值(primitive value)`就是最简单的数据, `引用值(reference value)`则是有多个值构成的对象

在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值

原始值：`Undefined、Null、Boolean、Number、String 和 Symbol`。保存原始值的变量是**按值（by value）**访问的，因为我们操作的就是存储在变量中的实际值

引用值是保存在内存中的对象. JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是**对该对象的引用（reference）**而非实际的对象本身, 保存引用值的变量是**按引用（by reference）**访问的

1. 动态属性

原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值

```js
/**
 * 创建了一个对象，并把它保存在变量 person 中
 * 个这个对象添加了一个名为 name 的属性
 */
let person = new Object()
person.name = "Nico"
console.log("person.name", person.name)

// 原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值

let name1 = "Nicholas"
let name2 = new String("Matt")
name1.age = 27
name2.age = 26
console.log(name1.age) // undefined
console.log(name2.age) // 26
console.log(typeof name1) // string
console.log(typeof name2) // object
```

2. 复制值

原始值和引用值在通过变量复制时也有所不同, 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置

```js
let num1 = 5
// 把 num2 初始化为 num1 时, num2 也会得到数值 5, 。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本
let num2 = num1
```

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置, 区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象

操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来

```js
// 变量 obj1 保存了一个新对象的实例
let obj1 = new Object() // 这个值被复制到 obj2, 此时两个变量都指向了同一个对象
let obj2 = obj1
obj1.name = "Nicholas"
console.log(obj2.name) // "Nicholas"
```

3. 传递参数

ECMAScript 中所有函数的参数都是按值传递的, 意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样, (变量有按值和按引用访问，而传参则只有按值传递)
**如果是原始值，那么就跟原始值变量的复制一样**
**如果是引用值，那么就跟引用值变量的复制一样**

```js
/**
 * 函数 addTen()有一个参数 num，它其实是一个局部变量
 * 在调用时，变量 count 作为参数传入
 * count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用
 * 在函数内部，参数 num的值被加上了 10，但这不会影响函数外部的原始变量 count
 * 参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值
 */
function addTen(num) {
  num += 10
  return num
}
let count = 20
let result = addTen(count)
console.log(count) // 20，没有变化
console.log(result) // 30

/**
 * 创建了一个对象并把它保存在变量 person 中
 * 这个对象被传给 setName()方法，并被复制到参数 obj 中
 * 在函数内部，obj 和 person 都指向同一个对象
 * 结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象
 * 因为 obj 指向的对象保存在全局作用域的堆内存上
 */
function setName(obj) {
  obj.name = "Nicholas"
}
let person = new Object()
setName(person)
console.log(person.name) // "Nicholas"

/**
 * 将 obj 重新定义为一个有着不同 name的新对象
 * 当 person 传入 setName()时，其 name 属性被设置为"Nicholas
 * 然后变量 obj 被设置为一个新对象且 name 属性被设置为"Greg"
 */
function setName(obj // 局部变量) {
  obj.name = "Nicholas"
  obj = new Object()
  obj.name = "Greg"
}
let person = new Object()
setName(person)
console.log(person.name) // "Nicholas"
```

4. 确定参数

typeof 操作符最适合用来`判断一个变量是否为原始类型`, 它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式

```js
let s = "Nicholas"
let b = true
let i = 22
let u
let n = null
let o = new Object()
console.log(typeof s) // string
console.log(typeof i) // number
console.log(typeof b) // boolean
console.log(typeof u) // undefined
console.log(typeof n) // object
console.log(typeof o) // object
```

ECMAScript 提供了 instanceof 操作符

- 如果变量是给定引用类型（由其原型链决定）的实例，则 instanceof 操作符返回 true

```js
result = variable instanceof constructor

// 按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true
console.log(person instanceof Object) // 变量 person 是 Object 吗？
console.log(colors instanceof Array) // 变量 colors 是 Array 吗？
console.log(pattern instanceof RegExp) // 变量 pattern 是 RegExp 吗？
```

### 执行上下文与作用域

执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定
了它们可以访问哪些数据，以及它们的行为

每个上下文都有一个关联的变量对象, 而这个上下文中定义的所有变量和函数都存在于这个对象上

全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一
样。在浏览器中，全局上下文就是我们常说的 window 对象, 因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法; 使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的

如果上下文是函数，则其活动对象（activation object）用作变量对象,活动对象最初只有
一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

```js
/**
 * 函数 changeColor()的作用域链包含两个对象:
 * 一个是它自己的变量对象（就是定义 arguments 对象的那个）
 * 另一个是全局上下文的变量对象
 */
var color = "blue"
function changeColor() {
  if (color === "blue") {
    color = "red"
  } else {
    color = "blue"
  }
}
changeColor()

/**
 * 局部作用域中定义的变量可用于在局部上下文中替换全局变量
 * 全局上下文中有一个变量 color 和一个函数 changeColor()。
 * changeColor()的局部上下文中有一个变量 anotherColor 和一个函数 swapColors()
 */
var color = "blue" // 全局上下文
function changeColor() {
  // changeColor()的局部上下文
  let anotherColor = "red"
  function swapColors() {
    // swapColors()的局部上下文
    let tempColor = anotherColor
    anotherColor = color
    color = tempColor
    // 这里可以访问 color、anotherColor 和 tempColor
  }
  // 这里可以访问 color 和 anotherColor，但访问不到 tempColor
  swapColors()
}
// 这里只能访问 color
changeColor()
```

内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西,每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索

1. 作用域链增强

虽然执行上下文主要有全局上下文和函数上下文两种, 但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时

- `try/catch` 语句的 `catch` 块
  - 对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明
- `with` 语句

```js
function buildUrl() {
  let qs = "?debug=true"
  // with 语句将 location 对象作为上下文
  with (location) {
    let url = href + qs
  }
  return url
}
```

2. 变量声明

- 使用`var`的函数作用域声明

使用 var 声明变量时，变量会被自动添加到最接近的上下文, 在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文

var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”

```js
function add(num1, num2) {
  // 函数 add()定义了一个局部变量 sum，保存加法操作的结果
  var sum = num1 + num2
  return sum
}
let result = add(10, 20) // 30
console.log(sum) // 报错：sum 在这里不是有效变量

function add(num1, num2) {
  // sum 被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。
  sum = num1 + num2
  return sum
}
let result = add(10, 20) // 30
console.log(sum) // 30
```

- 使用 `let` 的块级作用域声明

块级作用域由最近的`一对包含花括号{}`界定。换句话说，if 块、while 块、function 块，甚至单独的块也是 let 声明变量的作用域。

```js
if (true) {
  let a
}
console.log(a) // ReferenceError: a 没有定义
while (true) {
  let b
}

console.log(b) // ReferenceError: b 没有定义
function foo() {
  let c
}
console.log(c) // ReferenceError: c 没有定义
// 这没什么可奇怪的
// var 声明也会导致报错
// 这不是对象字面量，而是一个独立的块
// JavaScript 解释器会根据其中内容识别出它来
{
  let d
}
console.log(d) // ReferenceError: d 没有定义

// let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。

var a
var a
// 不会报错
{
  let b
  let b
}
// SyntaxError: 标识符 b 已经声明过了

// let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。
for (var i = 0; i < 10; ++i) {}
console.log(i) // 10
for (let j = 0; j < 10; ++j) {}
console.log(j) // ReferenceError: j 没有定义
```

- 使用 `const` 的常量声明

使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值

```js
const a; // SyntaxError: 常量声明时没有初始化
const b = 3;
console.log(b); // 3
b = 4; // TypeError: 给常量赋值


// const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制
const o1 = {};
o1 = {}; // TypeError: 给常量赋值
const o2 = {};
o2.name = 'Jake';
console.log(o2.name); // 'Jake'
```

### 垃圾回收

基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行

1. 标记清理

JavaScript 最常用的垃圾回收策略是`标记清理(mark-and-sweep)`. 当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记

给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下
文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现
并不重要，关键是策略

2. 引用计数

另一种没那么常用的垃圾回收策略是`引用计数(reference counting)`, 思路是对每个值都记录它被引用的次数。

引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：**循环引用**。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A

```js
function problem() {
  let objectA = new Object()
  let objectB = new Object()
  objectA.someOtherObject = objectB
  objectB.anotherObject = objectA
}
```

3. 内存管理

- 通过 const 和 let 声明提升性能, const/let 都是块级作用域
- 隐藏类和删除操作
- 内存泄露
  - 意外声明全局变量是最常见但也最容易修复的内存泄漏问题
  - 定时器也可能会悄悄地导致内存泄漏
  - JavaScript 闭包很容易在不知不觉间造成内存泄漏
- 静态分配与对象池

```js
function setName() {
  // 解释器会把变量 name 当作 window 的属性来创建
  // 只要在变量声明前头加上 var、let 或 const 关键字即可
  name = "Jake"
}

// 只要定时器一直运行，回调函数中引用的 name 就会一直占用内存
let name = "Jake"
setInterval(() => {
  console.log(name)
}, 100)

let outer = function () {
  let name = "Jake"
  // 要返回的函数存在就不能清理 name，因为闭包一直在引用着它
  return function () {
    return name
  }
}
```
