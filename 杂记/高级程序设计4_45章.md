## 4. 变量 作用域与内存

### 原始值与引用值

ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值. `原始值(primitive value)`就是最简单的数据, `引用值(reference value)`则是有多个值构成的对象

在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值

原始值：`Undefined、Null、Boolean、Number、String 和 Symbol`。保存原始值的变量是**按值（by value）**访问的，因为我们操作的就是存储在变量中的实际值

引用值是保存在内存中的对象. JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是**对该对象的引用（reference）**而非实际的对象本身, 保存引用值的变量是**按引用（by reference）**访问的

1. 动态属性

原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值

```js
/**
 * 创建了一个对象，并把它保存在变量 person 中
 * 个这个对象添加了一个名为 name 的属性
 */
let person = new Object()
person.name = "Nico"
console.log("person.name", person.name)

// 原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值

let name1 = "Nicholas"
let name2 = new String("Matt")
name1.age = 27
name2.age = 26
console.log(name1.age) // undefined
console.log(name2.age) // 26
console.log(typeof name1) // string
console.log(typeof name2) // object
```

2. 复制值

原始值和引用值在通过变量复制时也有所不同, 在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置

```js
let num1 = 5
// 把 num2 初始化为 num1 时, num2 也会得到数值 5, 。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本
let num2 = num1
```

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置, 区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象

操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来

```js
// 变量 obj1 保存了一个新对象的实例
let obj1 = new Object() // 这个值被复制到 obj2, 此时两个变量都指向了同一个对象
let obj2 = obj1
obj1.name = "Nicholas"
console.log(obj2.name) // "Nicholas"
```

3. 传递参数

ECMAScript 中所有函数的参数都是按值传递的, 意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样, (变量有按值和按引用访问，而传参则只有按值传递)
**如果是原始值，那么就跟原始值变量的复制一样**
**如果是引用值，那么就跟引用值变量的复制一样**

```js
/**
 * 函数 addTen()有一个参数 num，它其实是一个局部变量
 * 在调用时，变量 count 作为参数传入
 * count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用
 * 在函数内部，参数 num的值被加上了 10，但这不会影响函数外部的原始变量 count
 * 参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值
 */
function addTen(num) {
  num += 10
  return num
}
let count = 20
let result = addTen(count)
console.log(count) // 20，没有变化
console.log(result) // 30

/**
 * 创建了一个对象并把它保存在变量 person 中
 * 这个对象被传给 setName()方法，并被复制到参数 obj 中
 * 在函数内部，obj 和 person 都指向同一个对象
 * 结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象
 * 因为 obj 指向的对象保存在全局作用域的堆内存上
 */
function setName(obj) {
  obj.name = "Nicholas"
}
let person = new Object()
setName(person)
console.log(person.name) // "Nicholas"

/**
 * 将 obj 重新定义为一个有着不同 name的新对象
 * 当 person 传入 setName()时，其 name 属性被设置为"Nicholas
 * 然后变量 obj 被设置为一个新对象且 name 属性被设置为"Greg"
 */
function setName(obj // 局部变量) {
  obj.name = "Nicholas"
  obj = new Object()
  obj.name = "Greg"
}
let person = new Object()
setName(person)
console.log(person.name) // "Nicholas"
```

4. 确定参数

typeof 操作符最适合用来`判断一个变量是否为原始类型`, 它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式

```js
let s = "Nicholas"; 
let b = true; 
let i = 22; 
let u; 
let n = null; 
let o = new Object(); 
console.log(typeof s); // string 
console.log(typeof i); // number 
console.log(typeof b); // boolean 
console.log(typeof u); // undefined 
console.log(typeof n); // object 
console.log(typeof o); // object
```

ECMAScript 提供了 instanceof 操作符

- 如果变量是给定引用类型（由其原型链决定）的实例，则 instanceof 操作符返回 true

```js
result = variable instanceof constructor

// 按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true
console.log(person instanceof Object); // 变量 person 是 Object 吗？
console.log(colors instanceof Array); // 变量 colors 是 Array 吗？
console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
```

### 执行上下文与作用域
