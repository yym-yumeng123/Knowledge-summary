### 理解迭代

循环是迭代的基础, 它可以指定迭代的次数, 以及每次迭代执行什么操作, 每次循环都在下一次迭代开始之前完成

迭代会在一个有序集合上进行

```js
let collection = ["foo", "bar", "baz"]
for (let index = 0; index < collection.length; ++index) {
  console.log(collection[index])
}
```

- 迭代之前需要事先知道如何使用数据结构
- 遍历顺序并不是数据结构固有的

### 迭代器模式

迭代器模式描述了一个方案, 把有些结构称为 `可迭代对象`, 因为他们实现了正式的 `Iterable`接口

可迭代对象是一种抽象的说法, 基本上, 可以把可迭代对象理解成数组或集合这样的集合类型对象

```js
let arr = [1, 2, 3]
let set = new Set().add(1).add(2).add(3)
```

### 可迭代协议

实现 Iterable 接口（可迭代协议）要求同时具备两种能力: 支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力

- 字符串/数组/映射/集合/arguments 对象/NodeList 集合类型

```js
let str = "abc"
let arr = ["a", "b", "c"]
let map = new Map().set("a", 1).set("b", 2).set("c", 3)
let set = new Set().add("a").add("b").add("c")
let els = document.querySelectorAll("div")
// 这些类型都实现了迭代器工厂函数
console.log(str[Symbol.iterator]) // f values() { [native code] }
console.log(arr[Symbol.iterator]) // f values() { [native code] }
console.log(map[Symbol.iterator]) // f values() { [native code] }
console.log(set[Symbol.iterator]) // f values() { [native code] }
console.log(els[Symbol.iterator]) // f values() { [native code] }
```

- 接受可迭代对象的原生语言: `for-of循环/数据解构/扩展操作符/Array.from()/创建集合/创建映射/Promise.all()/Promise.race()/yield*`

```js
let [a, b, c] = arr
console.log(a, b, c) // foo, bar, baz

// 扩展操作符
let arr2 = [...arr]
console.log(arr2) // ['foo', 'bar', 'baz']
```

### 迭代器协议

迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象

迭代器 API 使用 `next()` 在可迭代对象中遍历数据, 包含两个属性: `done/value`

```js
let arr = ["foo", "bar"]
let iter = arr[Symbol.iterator]()
console.log(iter) // ArrayIterator {}

// 执行迭代
console.log(iter.next()) // { done: false, value: 'foo' }
console.log(iter.next()) // { done: false, value: 'bar' }
console.log(iter.next()) // { done: true, value: undefined }
```

### 自定义迭代器

```js
class Counter {
  constructor(limit) {
    this.limit = limit
  }
  [Symbol.iterator]() {
    let count = 1,
      limit = this.limit
    return {
      next() {
        if (count <= limit) {
          return { done: false, value: count++ }
        } else {
          return { done: true, value: undefined }
        }
      },
    }
  }
}

let counter = new Counter(3)

for (const i of counter) {
  console.log("i", i)
}
```

### 提前中止迭代器

可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑,执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括

- `for-of循环通过 break continue throw 提前退出`
- 解构操作并为消费所有值

return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。
