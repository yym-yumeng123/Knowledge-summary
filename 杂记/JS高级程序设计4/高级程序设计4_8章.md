### 理解对象

创建自定义对象的通常方式是创建一个`Object`的一个新实例, 然后在给它添加属性和方法

```js
let person = new Object()
person.name = "yym"
person.age = 18
person.job = "engineer"
person.sayNmae = function () {
  console.log("this.name", this.name)
}

// 对象字面量
let person = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name)
  },
}
```

#### 属性的类型

为了将某个特性标识为内部特性, 规范用两个中括号`[[]]`括起来

1. 数据属性

- `[[Configurable]]` 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性
- `[[Enumerable]]` 表示属性是否可以通过 `for-in` 循环
- `[[Writable]]` 表示属性的值是否可以被修改
- `[[Value]]` 包含属性实际的值

要修改属性的默认特性, 必须使用 `Object.defineProperty()` 方法, 接受三个参数: 给其添加属性的对象, 属性的名称和一个描述符对象

```js
let person = {}
Object.defineProperty(person, "name", {
  writable: false, // 只读
  configurable: false, // 不能从对象上删除
  value: "yym",
})
console.log("person.name", person.name)
person.name = "zhangsan"
console.log("person.name", person.name)
delete person.name
console.log("person.name", person.name)
```

2. 访问器属性

访问器属性不包含数据值, 他们包含一个`获取(getter)/ 设置(setter)`函数. 不过这两个函数不是必须的

在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值
在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改

- `[[Configurable]]` 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性
- `[[Enumerable]]`：表示属性是否可以通过 for-in 循环返回
- `[[Get]]` 获取函数, 读取属性时调用, 默认值 undefined
- `[[Set]]` 设置函数, 写入属性时调用, 默认值 undefined

不能直接定义, 必须使用 `Object.defineProperty()`

```js
let book = {
  year_: 2017,
  edition: 1,
}

Object.defineProperty(book, "year", {
  get() {
    return this.year_
  },
  set(newValue) {
    if (newValue > 2017) {
      this.year_ = newValue
      this.edition += newValue - 2017
    }
  },
})

book.year = 2018
console.log("book.edition", book.edition)
```

#### 定义多个属性

在一个对象上同时定义多个属性的可能性是非常大的, `Object.defineProperties()`

```js
let book = {}
Object.defineProperties(book, {
  year_: {
    value: 2017,
  },
  edition: {
    value: 1,
  },

  year: {
    get() {
      return this.year_
    },
    set(newValue) {
      if (newValue > 2017) {
        this.year_ = newValue
        this.edition += newValue - 2017
      }
    },
  },
})
```

#### 读取属性的特性

使用 `Object.getOwnPropertyDescriptor()` 可以取得指定属性的属性描述符,

```js
let book = {}
Object.defineProperties(book, {
  year_: {
    value: 2017,
  },
  edition: {
    value: 1,
  },

  year: {
    get() {
      return this.year_
    },
    set(newValue) {
      if (newValue > 2017) {
        this.year_ = newValue
        this.edition += newValue - 2017
      }
    },
  },
})
let descriptor = Object.getOwnPropertyDescriptor(book, "year_")
console.log("descriptor.value", descriptor.value) // 2017
console.log("descriptor.configurable", descriptor.configurable)
console.log(typeof descriptor.get) // "undefined"
let descriptor1 = Object.getOwnPropertyDescriptor(book, "year")
console.log(descriptor1.value) // undefined
console.log(descriptor1.enumerable) // false
console.log(typeof descriptor1.get) // "function"
```

#### 合并对象

把原对象的所有的本地属性一起复制到目标对象上, 有时候这种操作也叫 `mixin混入`, 因为目标对象通过混入源对象得到了增强

`Object.assign()` 接受一个目标对象, 一个或多个源对象作为参数, 执行的是浅复制

```js
let dest, src, result
/**
 * 简单复制
 */
dest = {}
src = { id: "src" }
result = Object.assign(dest, src)
// Object.assign 修改目标对象
// 也会返回修改后的目标对象
console.log(dest === result) // true
console.log(dest !== src) // true
console.log(result) // { id: src }
console.log(dest) // { id: src }
```

#### 对象标识及相等判定

`Object.is()`

```js
console.log(Object.is(true, 1)) // false
console.log(Object.is({}, {})) // false
console.log(Object.is("2", 2)) // false
// 正确的 0、-0、+0 相等/不等判定
console.log(Object.is(+0, -0)) // false
console.log(Object.is(+0, 0)) // true
console.log(Object.is(-0, 0)) // false
// 正确的 NaN 相等判定
console.log(Object.is(NaN, NaN)) // true

function recursivelyCheckEqual(x, ...rest) {
  return (
    Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest))
  )
}
```

#### 增强额对象语法

1. 属性值简写

```js
let name = "yym"
let person = {
  name: name,
}

// ==>
// 属性名和变量名一样
let person = {
  name,
}
```

2. 可计算属性

```js
const nameKey = "name"
const ageKey = "age"
const jobKey = "job"

let person = {}
person[nameKey] = "Matt"
person[ageKey] = 27
person[jobKey] = "Software engineer"

// 可计算属性
const nameKey = "name"
const ageKey = "age"
const jobKey = "job"
let uniqueToken = 0

let person = {
  [nameKey]: "Matt",
  [ageKey]: 27,
  [jobKey]: "Software engineer",
}

function getUniqueKey(key) {
  return `${key}_${uniqueToken++}`
}
let person = {
  [getUniqueKey(nameKey)]: "Matt",
  [getUniqueKey(ageKey)]: 27,
  [getUniqueKey(jobKey)]: "Software engineer",
}
```

3. 简写方法名

````js
let person = {
  sayName: function (name) {
    console.log(`My name is ${name}`)
  },
}

// ==>

let perosn = {
  sayName(name) {
    console.log(`My name is ${name}`)
  },
}
`

#### 对象解构

```js
// 不使用对象解构
let person = {
  name: "Matt",
  age: 27,
}
let personName = person.name,
  personAge = person.age
console.log(personName) // Matt
console.log(personAge) // 27

// 使用对象解构
let person = {
  name: "Matt",
  age: 27,
}
let { name: personName, age: personAge } = person
console.log(personName) // Matt
console.log(personAge) // 27
````

### 创建对象

#### 工厂模式

工厂模式是一种设计模式, 用于抽象创建特定对象的过程.

```js
function createPerson(name, age, job) {
  let o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayNmae = function () {
    console.log("this.name", this.name)
  }

  return o
}

let person1 = createPerson("yym", 18, "soft")
let person2 = createPerson("yym1", 20, "soft1")
```

#### 构造函数模式

ECMAScript 中的构造函数是用于创建特定类型对象的. 像 Object 和 Array 这样的原生构造函数, 运行时可以直接在执行环境中使用. 也可以自定义构造函数, 以函数的形式为自己的对象类型定义属性和方法, 前面的例子可以这样写:

```js
/**
 * 没有显示的创建对象
 * 属性和方法直接赋值给了 this
 * 没有 return
 * 
 * 构造函数名称首字母大写
 */
function Person(name, age, job) {
  this.name = name
  this.age = age
  this.job = job
  this.sayNmae = function () {
    console.log("this.name", this.name)
  }
}

let person3 = new Person("yym", 18, "soft")
let person4 = new Person("yym", 128, "soft1")

person3.sayNmae()
person4.sayNmae()

/**
 * new操作符,
 * 1. 在内存中创建了一个新对象
 * 2. 这个新对象内部的[[Prototype]] 特性被赋值为构造函数的 prototype 属性
 * 3. 构造函数内部的 this 被赋值为这个新对象(即 this 指向新对象)
 * 4. 执行构造函数内部的代码 ( 给对象添加属性)
 * 5. 如果构造函数返回非空对象, 返回该对象; 否则, 返回刚创建的新对象
 */
person3.construcor == Person
```

- 构造函数也是函数, 任何函数只要使用 new 操作符调用就是构造函数, 而不使用 new 操作符调用的函数就是普通函数
- 构造函数的主要问题: 其定义的方法会在每个实例上都创建一遍, 解决 -> 可以把函数定义转移到构造函数外部


#### 原型模式

