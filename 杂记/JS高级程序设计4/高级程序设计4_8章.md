### 理解对象

创建自定义对象的通常方式是创建一个`Object`的一个新实例, 然后在给它添加属性和方法

```js
let person = new Object()
person.name = "yym"
person.age = 18
person.job = "engineer"
person.sayNmae = function () {
  console.log("this.name", this.name)
}

// 对象字面量
let person = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name)
  },
}
```

#### 属性的类型

为了将某个特性标识为内部特性, 规范用两个中括号`[[]]`括起来

1. 数据属性

- `[[Configurable]]` 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性
- `[[Enumerable]]` 表示属性是否可以通过 `for-in` 循环
- `[[Writable]]` 表示属性的值是否可以被修改
- `[[Value]]` 包含属性实际的值

要修改属性的默认特性, 必须使用 `Object.defineProperty()` 方法, 接受三个参数: 给其添加属性的对象, 属性的名称和一个描述符对象

```js
let person = {}
Object.defineProperty(person, "name", {
  writable: false, // 只读
  configurable: false, // 不能从对象上删除
  value: "yym",
})
console.log("person.name", person.name)
person.name = "zhangsan"
console.log("person.name", person.name)
delete person.name
console.log("person.name", person.name)
```

2. 访问器属性

访问器属性不包含数据值, 他们包含一个`获取(getter)/ 设置(setter)`函数. 不过这两个函数不是必须的

在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值
在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改

- `[[Configurable]]` 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性
- `[[Enumerable]]`：表示属性是否可以通过 for-in 循环返回
- `[[Get]]` 获取函数, 读取属性时调用, 默认值 undefined
- `[[Set]]` 设置函数, 写入属性时调用, 默认值 undefined

不能直接定义, 必须使用 `Object.defineProperty()`

```js
let book = {
  year_: 2017,
  edition: 1,
}

Object.defineProperty(book, "year", {
  get() {
    return this.year_
  },
  set(newValue) {
    if (newValue > 2017) {
      this.year_ = newValue
      this.edition += newValue - 2017
    }
  },
})

book.year = 2018
console.log("book.edition", book.edition)
```

#### 定义多个属性

在一个对象上同时定义多个属性的可能性是非常大的, `Object.defineProperties()`

```js
let book = {}
Object.defineProperties(book, {
  year_: {
    value: 2017,
  },
  edition: {
    value: 1,
  },

  year: {
    get() {
      return this.year_
    },
    set(newValue) {
      if (newValue > 2017) {
        this.year_ = newValue
        this.edition += newValue - 2017
      }
    },
  },
})
```

#### 读取属性的特性

使用 `Object.getOwnPropertyDescriptor()` 可以取得指定属性的属性描述符,

```js
let book = {}
Object.defineProperties(book, {
  year_: {
    value: 2017,
  },
  edition: {
    value: 1,
  },

  year: {
    get() {
      return this.year_
    },
    set(newValue) {
      if (newValue > 2017) {
        this.year_ = newValue
        this.edition += newValue - 2017
      }
    },
  },
})
let descriptor = Object.getOwnPropertyDescriptor(book, "year_")
console.log("descriptor.value", descriptor.value) // 2017
console.log("descriptor.configurable", descriptor.configurable)
console.log(typeof descriptor.get) // "undefined"
let descriptor1 = Object.getOwnPropertyDescriptor(book, "year")
console.log(descriptor1.value) // undefined
console.log(descriptor1.enumerable) // false
console.log(typeof descriptor1.get) // "function"
```

#### 合并对象

把原对象的所有的本地属性一起复制到目标对象上, 有时候这种操作也叫 `mixin混入`, 因为目标对象通过混入源对象得到了增强

`Object.assign()` 接受一个目标对象, 一个或多个源对象作为参数, 执行的是浅复制

```js
let dest, src, result
/**
 * 简单复制
 */
dest = {}
src = { id: "src" }
result = Object.assign(dest, src)
// Object.assign 修改目标对象
// 也会返回修改后的目标对象
console.log(dest === result) // true
console.log(dest !== src) // true
console.log(result) // { id: src }
console.log(dest) // { id: src }
```

#### 对象标识及相等判定

`Object.is()`

```js
console.log(Object.is(true, 1)) // false
console.log(Object.is({}, {})) // false
console.log(Object.is("2", 2)) // false
// 正确的 0、-0、+0 相等/不等判定
console.log(Object.is(+0, -0)) // false
console.log(Object.is(+0, 0)) // true
console.log(Object.is(-0, 0)) // false
// 正确的 NaN 相等判定
console.log(Object.is(NaN, NaN)) // true

function recursivelyCheckEqual(x, ...rest) {
  return (
    Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest))
  )
}
```

#### 增强额对象语法

1. 属性值简写

```js
let name = "yym"
let person = {
  name: name,
}

// ==>
// 属性名和变量名一样
let person = {
  name,
}
```

2. 可计算属性

```js
const nameKey = "name"
const ageKey = "age"
const jobKey = "job"

let person = {}
person[nameKey] = "Matt"
person[ageKey] = 27
person[jobKey] = "Software engineer"

// 可计算属性
const nameKey = "name"
const ageKey = "age"
const jobKey = "job"
let uniqueToken = 0

let person = {
  [nameKey]: "Matt",
  [ageKey]: 27,
  [jobKey]: "Software engineer",
}

function getUniqueKey(key) {
  return `${key}_${uniqueToken++}`
}
let person = {
  [getUniqueKey(nameKey)]: "Matt",
  [getUniqueKey(ageKey)]: 27,
  [getUniqueKey(jobKey)]: "Software engineer",
}
```

3. 简写方法名

````js
let person = {
  sayName: function (name) {
    console.log(`My name is ${name}`)
  },
}

// ==>

let perosn = {
  sayName(name) {
    console.log(`My name is ${name}`)
  },
}
`

#### 对象解构

```js
// 不使用对象解构
let person = {
  name: "Matt",
  age: 27,
}
let personName = person.name,
  personAge = person.age
console.log(personName) // Matt
console.log(personAge) // 27

// 使用对象解构
let person = {
  name: "Matt",
  age: 27,
}
let { name: personName, age: personAge } = person
console.log(personName) // Matt
console.log(personAge) // 27
````

### 创建对象

#### 工厂模式

工厂模式是一种设计模式, 用于抽象创建特定对象的过程.

```js
function createPerson(name, age, job) {
  let o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayNmae = function () {
    console.log("this.name", this.name)
  }

  return o
}

let person1 = createPerson("yym", 18, "soft")
let person2 = createPerson("yym1", 20, "soft1")
```

#### 构造函数模式

ECMAScript 中的构造函数是用于创建特定类型对象的. 像 Object 和 Array 这样的原生构造函数, 运行时可以直接在执行环境中使用. 也可以自定义构造函数, 以函数的形式为自己的对象类型定义属性和方法, 前面的例子可以这样写:

```js
/**
 * 没有显示的创建对象
 * 属性和方法直接赋值给了 this
 * 没有 return
 *
 * 构造函数名称首字母大写
 */
function Person(name, age, job) {
  this.name = name
  this.age = age
  this.job = job
  this.sayNmae = function () {
    console.log("this.name", this.name)
  }
}

let person3 = new Person("yym", 18, "soft")
let person4 = new Person("yym", 128, "soft1")

person3.sayNmae()
person4.sayNmae()

/**
 * new操作符,
 * 1. 在内存中创建了一个新对象
 * 2. 这个新对象内部的[[Prototype]] 特性被赋值为构造函数的 prototype 属性
 * 3. 构造函数内部的 this 被赋值为这个新对象(即 this 指向新对象)
 * 4. 执行构造函数内部的代码 ( 给对象添加属性)
 * 5. 如果构造函数返回非空对象, 返回该对象; 否则, 返回刚创建的新对象
 */
person3.construcor == Person
```

- 构造函数也是函数, 任何函数只要使用 new 操作符调用就是构造函数, 而不使用 new 操作符调用的函数就是普通函数
- 构造函数的主要问题: 其定义的方法会在每个实例上都创建一遍, 解决 -> 可以把函数定义转移到构造函数外部

#### 原型模式

每个函数都会创建一个 prototype 属性, 这个属性是一个对象, 包含应该由特定引用类型的实例共享的属性和方法. 使用原型对象的好处: 在它上面定义的属性和方法可以被对象实例共享.

```js
function Person() {}
Person.prototype.name = "Nicholas"
Person.prototype.age = 29
Person.prototype.job = "Software Engineer"
Person.prototype.sayName = function () {
  console.log(this.name)
}
let person1 = new Person()
person1.sayName() // "Nicholas"
let person2 = new Person()
person2.sayName() // "Nicholas"
console.log(person1.sayName == person2.sayName) // true
```

1. 理解原型

无论何时, 只要创建一个函数, 就会按照特定的规则为这个函数创建一个 `prototype` 属性(指向原型对象). 默认情况下, 所有原型对象自动获得一个名为 `constructor` 的属性, 指回与之关联的构造函数,

```js
Person.prototype.constructor === Person // true
```

在自定义构造函数时, 原型对象默认只会获得 `constructor` 属性, 其它所有方法继承自 Object. 每次调用构造函数创建一个新实例, 这个实例的内部 `[[Prototype]]` 指针就会被赋值为构造函数的原型对象 `__proto__`

```js
/**
 * 构造函数可以是函数表达式
 * 也可以是函数声明
 * function Person(){}
 * let Person = function() {}
 */
function Person() {}

/**
 * 声明之后, 构造函数就有了一个与之关联的原型对象
 */
typeof Person.prototype // object

/**
 * 如上所述, 构造函数有一个 prototype 属性 引用其原型对象, 而这个原型对象也有一个 constructor 属性, 引用这个构造函数.
 * 两者循环引用
 */
Person.prototype.construtor === Person // true

/**
 * 正常的原型链,都会终止与 Object 的原型对象
 * Object 原型对象是 null
 */
Person.prototype.__proto__ === Object.prototype
Person.prototype.__proto__.construtor === Object
Person.prototype.__proto__.__proto__ === null

/**
 * 构造函数 原型对象和实例
 * 是三个完全不同的对象
 */
person1 !== Person // true 实例 !== 构造函数
person1 !== Person.prototype // true 实例 !== 原型对象
Person.prototype !== Person // true 原型对象 !== 构造函数

/**
 * 实例通过 __proto__ 链接到原型对象
 * 他实际指向隐藏特性 [[Prototype]]
 *
 * 构造函数通过 prototype 属性链接到原型对象
 *
 * 实例与构造函数没有直接联系, 与原型对象有直接联系
 */
person1.__proto__ === Person.prototype // true
person1.__proto__.constructor === Person // true

/**
 * 同一个构造函数创建两个实例
 * 共享同一个原型对象
 */
perosn1.__proto__ === person2.__proto__

/**
 * instanceof 检查实例在原型链中是否包含指定构造函数的原型
 */
person1 instanceof Person // true
person instanceof Object // true
Person.prototype instanceof Object // true
```

2. 原型层级

在通过对象访问属性时, 会按照这个属性的名称开始搜索, 搜索开始于对象实例本身.如果在这个实力上发现了给定的名称, 则返回该名称对应的值, 如果没有找到, 则搜索会沿着指针进入原型对象, 在原型对象上找到该属性后, 再返回对应的值.

虽然可以通过实例读取原型对象上的值, 但不可能通过实例重写这些值. 如果在实例上添加与原型对象中同名的属性, 就会在实例上创建这个属性, 这个属性会遮住原型对象上的属性.

```js
function Person() {}
Person.prototype.name = "Nicholas"
Person.prototype.age = 29
Person.prototype.job = "Software Engineer"
Person.prototype.sayName = function () {
  console.log(this.name)
}
let person1 = new Person()
let person2 = new Person()
person1.name = "Greg"
console.log(person1.name) // "Greg"，来自实例
console.log(person2.name) // "Nicholas"，来自原型
```

`hasOwnProperty()` 方法用于确定某个属性是在实例上还是在原型对象上.

3. 原型和 `in` 操作符

有两种方式使用 in 操作符: `单独使用`和在`for-in` 循环中使用.
`in` 操作符会在可以通过对象访问指定属性时返回 true, 无论该属性是在实例上还是在原型上

```js
let person1 = new Person()
let person2 = new Person()

console.log(person1.hasOwnProperty("name")) // false
console.log("name" in person1) // true

person1.name = "Greg"
console.log(person1.name) // "Greg"，来自实例
console.log(person1.hasOwnProperty("name")) // true
"name" in person1 // true

console.log(person2.name) // "Nicholas"，来自原型
console.log(person2.hasOwnProperty("name")) // false
"name" in person2 // true
```

如果邀确定某个属性是否存在于原型上, 可以像下面

```js
function hasPrototypeProperty(object, name) {
  return !object.hasOwnProperty(name) && name in object
}
```

在 `for-in` 循环中使用 in 操作符, 可以通过对象访问并且可以被枚举的属性都会返回, 包括实例属性和原型属性. 遮蔽原型中不可枚举`([[Enumerble]]特性被设置为false)`属性的实例属性也会在 for-in 循环中返回, 因为默认情况下开发者定义的属性都是可枚举的

要获得对象上所有可枚举的实例属性，可以使用 `Object.keys()`方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组

```js
let key = Object.keys(Person.prototype) //  ['name', 'age', 'job', 'sayName']
```

4. 属性枚举顺序

for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbol()以及 Object.assign()在属性枚举顺序方面有很大区别。

for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异
Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。

#### 对象迭代

执行对象的浅复制

- `Object.values()` 接收一个对象, 返回对象值的数组
- `Object.entries()` 接收一个对象, 返回键/值对的数组

```js
const o = {
  foo: "bar",
  baz: 1,
  qux: {},
}
console.log(Object.values(o)) // ["bar", 1, {}]
console.log(Object.entries(o)) // [["foo", "bar"], ["baz", 1], ["qux", {}]]
```

1. 其它原型语法

```js
function Person() {}
// 减少代码冗余
Person.prototype = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name)
  },
}

// 上面重写以后, Person.prototype 的 constructor 属性不指向 Person,
Person.prototype = {
  constructor: Person, // 可以添加
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName() {
    console.log(this.name)
  },
}
```

2. 原型的动态性

```js
// friend 实例是在添加方法之前创建的, 仍然可以访问这个方法
let friend = new Person()
Person.prototype.sayHi = function () {
  console.log("hi")
}
friend.sayHi() // "hi"，没问题！

// 因为实例和原型之间的链接就是简单的指针, 而不是保存的副本
```

3. 原生对象原型

因为它也是实现所有原生引用类型的模式, 所有原生引用类型的构造函数都在原型上定义了实例方法

4. 原型的问题

- 它弱化了向构造函数传递初始化参数的能力, 会导致所有实例默认都取得相同的属性值.
- 共享特性, 原型上所有属性在实例上是共享的, 问题来自引用值的属性

```js
function Person() {}
Person.prototype = {
  constructor: Person,
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  friends: ["Shelby", "Court"],
  sayName() {
    console.log(this.name)
  },
}
let person1 = new Person()
let person2 = new Person()
person1.friends.push("Van")
console.log(person1.friends) // "Shelby,Court,Van"
console.log(person2.friends) // "Shelby,Court,Van"
console.log(person1.friends === person2.friends) // true
```
