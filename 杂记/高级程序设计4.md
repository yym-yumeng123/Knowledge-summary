- ECMAScript -> 由 ECMA-262 定义并提供核心功能
- DOM + SVG + MathML + SMIL -> 提供与网页内容交互的方法和接口
- BOM 针对浏览器窗口和子窗口
  - 弹出新浏览器窗口的能力
  - 移动, 缩放和关闭浏览器的能力
  - navigation 对象 -> 关于浏览器的详尽信息
  - location 对象 -> 浏览器加载页面的详尽信息
  - screen 对象 -> 关于用户屏幕分辨率的详尽信息
  - performance 对象 -> 供浏览器内存占用、导航行为和时间统计的详尽信息
  - 对 cookie 的支持
  - 其他自定义对象, XMLHttpRequest

---

1. `<script> 元素`

- async 可选, 表示应该立即开始下载脚本，但不能阻止其他页面动作
- charset 可选, 使用 src 属性指定的代码字符集
- crossorigin 可选, 配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS
- defer 可选, 表示脚本可以延迟到文档完全被解析和显示之后再执行, 只对外部脚本有效
- integrity 可选, 允许比对接收到的资源和指定的加密签名以验证子资源完整性
- src 可选, 表示包含要执行的代码的外部文件
- type 可选, 代替 language，表示代码块中脚本语言的内容类型

```html
<script>
  function sayHi() {
    console.log("Hi")
  }
</script>

<script src="example.js"></script>

<!-- 浏览器在解析这个资源时, 向src发送一个get请求 -->
<script src="http://www.somewhere.com/afile.js"></script>
```

2. 标签位置

```html
<!DOCTYPE html>
<html>
  <!-- 是把外部的 CSS 和 JavaScript 文件都集中放到一起  -->
  <head>
    <title>Example HTML Page</title>
    <!-- 意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面 -->
    <script src="example1.js"></script>
    <script src="example2.js"></script>
  </head>
  <body>
    <!-- 这里是页面内容 -->
  </body>
</html>

<!DOCTYPE html>
<html>
  <head>
    <title>Example HTML Page</title>
  </head>
  <body>
    <!-- 这里是页面内容 -->
    <!-- 页面会在处理 JavaScript 代码之前完全渲染页面 -->
    <script src="example1.js"></script>
    <script src="example2.js"></script>
  </body>
</html>
```

```html
<!-- 设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行 -->
<script defer src="example1.js"></script>

<!-- 它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载 -->
<!-- 标记为 async 的脚本并不保证能按照它们出现的次序执行 -->
<script async src="example2.js"></script>
```

```js
// 动态加载脚本
let script = document.createElement("script")
script.src = "demo.js"
script.async = false
document.head.appendChild(script)
```

3. 行内代码与外部文件 -> 推荐使用外部文件

- 可维护性
- 缓存
- 适应未来

4. `<noscript> 元素`

```
<noscript>元素可以包含任何可以出现在<body>中的 HTML 元素，<script>除外
```

任何一个条件被满足，包含在<noscript>中的内容就会被渲染

- 浏览器不支持脚本；
- 浏览器对脚本的支持被关闭

---

### 语法基础

- 区分大小写
- 标识符 -> 就是变量/函数/属性/函数参数的名称 (驼峰 firstSecond)

  - 第一个字符必须是一个字母、下划线（\_）或美元符号（$）
  - 剩下的其他字符可以是字母、下划线、美元符号或数字

- 注释

```js
// 单行注释

/**
 * 多行注释
 */
```

- 严格模式

```js
"use strict"

function doSomething() {
  "use strict"
  // 函数体
}
```

- 语句

  - 以分号结尾(推荐)
  - 多条语句可以合并到一个 C 语言风格的代码块中。代码块由一个左花括号（{）标识开始，一个右花括号（}）标识结束

- 关键字和保留字

  - break/do/in/typeof/else/var/... 等等
  - enum (保留字)

- 变量
  - 变量是松散类型的, 可用于保存任何类型的数据, 每个变量只不过是一个用于保存人一直的命名占位符, 有三个关键字可以声明变量: `var let const`

```js
// var
var message // undefined
var message = "hi"
message = 100 // 不推荐改变变量保存值的类型

// 1. var 声明作用域
function test() {
  var message = "hi" // 局部变量
}
test() // 调用之后变量随即被销毁
console.log(message) // 出错

function test() {
  message = "hi" // 全局变量
}
test()
console.log(message) // "hi"

// 定义多个变量
var message = "hi",
  found = false,
  age = 29

// var 声明提升 把所有变量声明都拉到函数作用域的顶部
function foo() {
  console.log(age)
  var age = 26
}
foo() // undefined

function foo() {
  var age
  console.log(age)
  age = 26
}
foo() // undefined
```

```js
// let 声明
// let 声明的范围是块作用域, var 声明的范围是函数作用域

if (true) {
  var name = "matt"
  console.log("name", name) // matt
}
console.log("name", name) // matt

if (true) {
  // 它的作用域仅限于该块内部
  let age = 26
  console.log(age) // 26
}
console.log(age) // ReferenceError: age 没有定义

// let 也不允许同一个块作用域中出现冗余声明
let age
let age // 标识符 age 已经声明过了

// 暂时性死区
// let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升
// 在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 ReferenceError
// name 会被提升
console.log(name) // undefined
var name = "Matt"
// age 不会被提升
console.log(age) // ReferenceError：age 没有定义
let age = 26

// 全局声明
// 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性

let age = 26
console.log(window.age) // undefined

// 条件声明
// 因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。

// for 循环中的 let 声明
for (var i = 0; i < 5; ++i) {
  // 循环逻辑
}
console.log(i) // 5

// 因为迭代变量的作用域仅限于 for 循环块内部
for (let i = 0; i < 5; ++i) {
  // 循环逻辑
}
console.log(i) // ReferenceError: i 没有定义

/**
 * 在推出循环时, 迭代变量保存的是导致循环退出的值 5, 之后执行超时逻辑, 所有的i 都是同一个变量, 因而输出的都是同一个最终值
 *
 * 在使用let声明迭代变量时, js引擎在后台为每个迭代循环声明新的迭代变量, 每个 setTimeout 引用的都是不用的变量实例
 */
for (var i = 0; i < 5; ++i) {
  setTimeout(() => console.log(i), 0)
}
// 你可能以为会输出 0、1、2、3、4
// 实际上会输出 5、5、5、5、5

// 这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of循环
```

```js
// const 声明
// const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误

const age = 26
age = 36 // TypeError

// const 也不允许重复声明
const name = "Matt"
const name = "Nicholas" // SyntaxError

// const 声明的作用域也是块
const name = "Matt"
if (true) {
  const name = "Nicholas"
}
console.log(name) // Matt

// const 声明的限制只适用于它指向的变量的引用, 如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制

const person = {}
person.name = "Matt" // ok
```

### 数据类型

- 6 种简单数据类型(原始类型): `Undefined Null Boolean String Number Symbol`
- 1 种复杂数据类型: `Object(对象)`, Object 是一种无序名值对的集合

1. typeof 操作符

需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一

- "undefined"表示值未定义；
- "boolean"表示值为布尔值；
- "string"表示值为字符串；
- "number"表示值为数值；
- "object"表示值为对象（而不是函数）或 null；
- "function"表示值为函数；
- "symbol"表示值为符号。

2. Undefined 类型

Undefined 类型只有一个值，就是特殊值 undefined, 当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值

```js
let message
console.log(message == undefined) // true

// 包含 undefined 值的变量跟未定义变量是有区别的
let message // 这个变量被声明了，只是值为 undefined
// 确保没有声明过这个变量
// let age
console.log(message) // "undefined"
console.log(age) // 报错
```

3. Null 类型

Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回"object"的原因

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用

```js
// undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等
console.log(null == undefined) // true

// 永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量
```

4. Boolean 类型

Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false

```js
// 布尔值字面量 true 和 false 是区分大小写的
let found = true
let lost = false

// 要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数
let message = "Hello world!"
let messageAsBoolean = Boolean(message)

/**
 * 转换为 false 的值
 * ""
 * 0 NaN
 * null
 * undefined
 * false
 */
```

5. Number 类型

ECMAScript 中最有意思的数据类型或许就是 Number 了。Number 类型使用 IEEE 754 格式表整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式

最基本的数值字面量格式是十进制整数

```js
let intNum = 55 // 整数
```

整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示

- 对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）. 如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数

- 要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0~9 以及 A~F）。十六进制数字中的字母大小写均可。

```js
let octalNum1 = 070 // 八进制的 56
let octalNum2 = 079 // 无效的八进制值，当成 79 处理
let octalNum3 = 08 // 无效的八进制值，当成 8 处理

let hexNum1 = 0xa // 十六进制 10
let hexNum2 = 0x1f // 十六进制 31
```

- 浮点值

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字, 因为存储浮点值使用内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。

```js
let floatNum1 = 1.1
let floatNum2 = 0.1
let floatNum3 = 0.1 // 有效，但不推荐
```

对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值, ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂

```js
// 浮点值的精确度最高可达 17 位小数
let floatNum = 3.125e7 // 等于 31250000
```

- 值的范围

ECMAScript 可以表示的最小数值保存在 `Number.MIN_VALUE` 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保在`Number.MAX_VALUE` 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308

如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为个特殊的 `Infinity`（无穷）值。任何无法表示的负数以`-Infinity`（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示

```js
let result = Number.MAX_VALUE + Number.MAX_VALUE
console.log(isFinite(result)) // false
```

- NaN

有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。

```js
console.log(0 / 0) // NaN
console.log(-0 / +0) // NaN

// 任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）
// NaN 不等于包括 NaN 在内的任何值

console.log(NaN == NaN) // false

// ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”

console.log(isNaN(NaN)) // true
console.log(isNaN(10)) // false，10 是数值
console.log(isNaN("10")) // false，可以转换为数值 10
console.log(isNaN("blue")) // true，不可以转换为数值
console.log(isNaN(true)) // false，可以转换为数值 1
```

- 数值转换

```js
Number()
parseInt()
parseFloat()

// Number() 是转型函数, 可用于任何数据类型, 后两个函数用于将字符串转换为数值

/**
 * Number() 转换规则
 * 布尔值 -> true: 1 false: 0
 * 数值 -> 直接返回
 * null -> 0
 * undefined -> NaN
 * 字符串 -> Number("1"): 1 Number("011"): 11
 *   Number('0a1b'): NaN Number(""): 0
 * 对象, 调用 valueOf() 方法,
 */

let num1 = Number("Hello world!") // NaN
let num2 = Number("") // 0
let num3 = Number("000011") // 11
let num4 = Number(true) // 1

/**
 * parseInt()函数更专注于字符串是否包含数值模式, 字符串最前面的空格会被忽略，从第一个字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN
 * 这意味着空字符串也会返回 NaN
 * 如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符
 */

let num1 = parseInt("1234blue") // 1234
let num2 = parseInt("") // NaN
let num3 = parseInt("0xA") // 10，解释为十六进制整数
let num4 = parseInt(22.5) // 22
let num5 = parseInt("70") // 70，解释为十进制值
let num6 = parseInt("0xf") // 15，解释为十六进制整数

// parseInt()也接收第二个参数，用于指定底数
let num = parseInt("0xAF", 16) // 175
let num1 = parseInt("AF", 16) // 175
let num2 = parseInt("AF") // NaN

/**
 * parseFloat()函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略
 *
 * parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零
 *
 * parseFloat()只解析十进制值，因此不能指定底数
 */

let num1 = parseFloat("1234blue") // 1234，按整数解析
let num2 = parseFloat("0xA") // 0
let num3 = parseFloat("22.5") // 22.5
let num4 = parseFloat("22.34.5") // 22.34
let num5 = parseFloat("0908.5") // 908.5
let num6 = parseFloat("3.125e7") // 31250000
```

6. String 类型

String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列, 字符串可以使用双引（"）、单引号（'）或反引号（`）标示，

```js
let firstName = "John"
let lastName = "Jacob"
let lastName = `Jingleheimerschmidt`
```

- 把一个值转换为字符串。首先是使用几乎所有值都有的 `toString()` 方法

```js
// toString()方法可见于数值、布尔值、对象和字符串值。
// null 和 undefined 值没有 toString()方法
let age = 11
let ageAsString = age.toString() // 字符串"11"
let found = true
let foundAsString = found.toString() // 字符串"true"

// 多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时, toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示

// ，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示

let num = 10
console.log(num.toString()) // "10"
console.log(num.toString(2)) // "1010"
console.log(num.toString(8)) // "12"
console.log(num.toString(10)) // "10"

// String() 转型函数
/**
 * 你不确定一个值是不是 null 或 undefined, 可以使用 String()转型函数
 * 如果值有 toString()方法，则调用该方法（不传参数）并返回结果
 * 如果值是 null，返回"null"
 * 如果值是 undefined，返回"undefined"
 */

let value1 = 10
let value2 = true
let value3 = null
let value4
console.log(String(value1)) // "10"
console.log(String(value2)) // "true"
console.log(String(value3)) // "null"
console.log(String(value4)) // "undefined"
```

- 模板字面量

```js
let myMultiLineString = "first line\nsecond line"
let myMultiLineTemplateLiteral = `first line 
second line`
console.log(myMultiLineString)
// first line
// second line"
console.log(myMultiLineTemplateLiteral)
// first line
// second line
console.log(myMultiLineString === myMultiLinetemplateLiteral) // true
```

```js
let pageHTML = ` 
<div> 
 <a href="#"> 
 <span>Jake</span> 
 </a> 
</div>`
```

- 字符串插值 `${}`

模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值

```js
let value = 5
let exponent = "second"
// 以前，字符串插值是这样实现的：
let interpolatedString =
  value + " to the " + exponent + " power is " + value * value
// 现在，可以用模板字面量这样实现：
let interpolatedTemplateLiteral = `${value} to the ${exponent} power is ${
  value * value
}`
console.log(interpolatedString) // 5 to the second power is 25
console.log(interpolatedTemplateLiteral) // 5 to the second power is 25
```

- 模板字面量标签函数

模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果

标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为

```js
let a = 6
let b = 9
function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
  console.log(strings)
  console.log(aValExpression)
  console.log(bValExpression)
  console.log(sumExpression)
  return "foobar"
}
let untaggedResult = `${a} + ${b} = ${a + b}`
let taggedResult = simpleTag`${a} + ${b} = ${a + b}`
// ["", " + ", " = ", ""]
// 6
// 9
// 15
console.log(untaggedResult) // "6 + 9 = 15"
console.log(taggedResult) // "foobar"
```

- 原始字符串

使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示

```js
// Unicode 示例
// \u00A9 是版权符号
console.log(`\u00A9`) // ©
console.log(String.raw`\u00A9`) // \u00A9

// 换行符示例
console.log(`first line\nsecond line`)
// first line
// second line
```
