- ECMAScript -> 由 ECMA-262 定义并提供核心功能
- DOM + SVG + MathML + SMIL -> 提供与网页内容交互的方法和接口
- BOM 针对浏览器窗口和子窗口
   - 弹出新浏览器窗口的能力
   - 移动, 缩放和关闭浏览器的能力
   - navigation 对象 -> 关于浏览器的详尽信息
   - location 对象 -> 浏览器加载页面的详尽信息
   - screen 对象 -> 关于用户屏幕分辨率的详尽信息
   - performance 对象 -> 供浏览器内存占用、导航行为和时间统计的详尽信息
   - 对 cookie 的支持
   - 其他自定义对象, XMLHttpRequest

---

1. `<script> 元素`
  - async 可选, 表示应该立即开始下载脚本，但不能阻止其他页面动作
  - charset 可选, 使用 src 属性指定的代码字符集
  - crossorigin 可选, 配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS
  - defer 可选, 表示脚本可以延迟到文档完全被解析和显示之后再执行, 只对外部脚本有效
  - integrity 可选, 允许比对接收到的资源和指定的加密签名以验证子资源完整性
  - src 可选, 表示包含要执行的代码的外部文件
  - type 可选, 代替 language，表示代码块中脚本语言的内容类型

```html
<script>
  function sayHi() {
    console.log('Hi')
  }
</script>

<script src="example.js"></script>


<!-- 浏览器在解析这个资源时, 向src发送一个get请求 -->
<script src="http://www.somewhere.com/afile.js"></script> 
```

2. 标签位置

```html
<!DOCTYPE html> 
<html> 
 <!-- 是把外部的 CSS 和 JavaScript 文件都集中放到一起  -->
 <head> 
 <title>Example HTML Page</title> 
 <!-- 意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面 -->
 <script src="example1.js"></script> 
 <script src="example2.js"></script> 
 </head> 
 <body> 
 <!-- 这里是页面内容 --> 
 </body> 
</html>

<!DOCTYPE html> 
<html> 
 <head> 
 <title>Example HTML Page</title> 
 </head> 
 <body> 
 <!-- 这里是页面内容 --> 
 <!-- 页面会在处理 JavaScript 代码之前完全渲染页面 -->
 <script src="example1.js"></script> 
 <script src="example2.js"></script> 
 </body> 
</html> 
```

```html
<!-- 设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行 -->
<script defer src="example1.js"></script>

<!-- 它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载 -->
<!-- 标记为 async 的脚本并不保证能按照它们出现的次序执行 -->
<script async src="example2.js"></script>
```

```js
// 动态加载脚本
let script = document.createElement('script')
script.src = 'demo.js'
script.async = false;
document.head.appendChild(script)
```

3. 行内代码与外部文件 -> 推荐使用外部文件
  - 可维护性
  - 缓存
  - 适应未来

4. `<noscript> 元素`

```
<noscript>元素可以包含任何可以出现在<body>中的 HTML 元素，<script>除外
```
任何一个条件被满足，包含在<noscript>中的内容就会被渲染

- 浏览器不支持脚本；
- 浏览器对脚本的支持被关闭


----

### 语法基础

- 区分大小写
- 标识符 -> 就是变量/函数/属性/函数参数的名称 (驼峰 firstSecond)
  - 第一个字符必须是一个字母、下划线（_）或美元符号（$）
  - 剩下的其他字符可以是字母、下划线、美元符号或数字

- 注释
```js
// 单行注释

/**
 * 多行注释
 */
```

- 严格模式

```js
"use strict"

function doSomething() { 
 "use strict"; 
 // 函数体 
} 
```

- 语句
   - 以分号结尾(推荐)
   - 多条语句可以合并到一个 C 语言风格的代码块中。代码块由一个左花括号（{）标识开始，一个右花括号（}）标识结束

- 关键字和保留字
   - break/do/in/typeof/else/var/... 等等
   - enum (保留字)

- 变量
   - 变量是松散类型的, 可用于保存任何类型的数据, 每个变量只不过是一个用于保存人一直的命名占位符, 有三个关键字可以声明变量: `var let const`

```js
// var 
var message; // undefined
var message = 'hi'
message = 100 // 不推荐改变变量保存值的类型

// 1. var 声明作用域
function test() {
  var message = 'hi' // 局部变量
}
test() // 调用之后变量随即被销毁
console.log(message) // 出错

function test() { 
 message = "hi"; // 全局变量
} 
test(); 
console.log(message); // "hi"

// 定义多个变量
var message = 'hi', found = false, age = 29

// var 声明提升 把所有变量声明都拉到函数作用域的顶部
function foo() { 
 console.log(age); 
 var age = 26; 
} 
foo(); // undefined

function foo() { 
 var age; 
 console.log(age); 
 age = 26; 
} 
foo(); // undefined
```


```js
// let 声明
// let 声明的范围是块作用域, var 声明的范围是函数作用域

if (true) {
  var name = "matt"
  console.log("name", name) // matt
}
console.log("name", name) // matt

if (true) { 
  // 它的作用域仅限于该块内部
 let age = 26; 
 console.log(age); // 26 
} 
console.log(age); // ReferenceError: age 没有定义

// let 也不允许同一个块作用域中出现冗余声明
let age;
let age; // 标识符 age 已经声明过了


// 暂时性死区
// let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升
// 在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 ReferenceError
// name 会被提升
console.log(name); // undefined 
var name = 'Matt'; 
// age 不会被提升
console.log(age); // ReferenceError：age 没有定义
let age = 26; 


// 全局声明
// 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性

let age = 26; 
console.log(window.age); // undefined

// 条件声明
// 因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。


// for 循环中的 let 声明
for (var i = 0; i < 5; ++i) { 
 // 循环逻辑 
} 
console.log(i); // 5

// 因为迭代变量的作用域仅限于 for 循环块内部
for (let i = 0; i < 5; ++i) { 
 // 循环逻辑
} 
console.log(i); // ReferenceError: i 没有定义

/**
 * 在推出循环时, 迭代变量保存的是导致循环退出的值 5, 之后执行超时逻辑, 所有的i 都是同一个变量, 因而输出的都是同一个最终值
 * 
 * 在使用let声明迭代变量时, js引擎在后台为每个迭代循环声明新的迭代变量, 每个 setTimeout 引用的都是不用的变量实例
 */
for (var i = 0; i < 5; ++i) { 
 setTimeout(() => console.log(i), 0) 
} 
// 你可能以为会输出 0、1、2、3、4 
// 实际上会输出 5、5、5、5、5 

// 这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of循环
```

```js
// const 声明
// const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误

const age = 26
age = 36 // TypeError

// const 也不允许重复声明
const name = 'Matt'; 
const name = 'Nicholas'; // SyntaxError 

// const 声明的作用域也是块
const name = 'Matt'; 
if (true) { 
 const name = 'Nicholas'; 
} 
console.log(name); // Matt 

// const 声明的限制只适用于它指向的变量的引用, 如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制

const person = {}; 
person.name = 'Matt'; // ok
```

### 数据类型

- 6种简单数据类型(原始类型): `Undefined Null Boolean String Number Symbol`
- 1种复杂数据类型: `Object(对象)`, Object 是一种无序名值对的集合

1. typeof 操作符

需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一

- "undefined"表示值未定义；
- "boolean"表示值为布尔值；
- "string"表示值为字符串；
- "number"表示值为数值；
- "object"表示值为对象（而不是函数）或 null；
- "function"表示值为函数；
- "symbol"表示值为符号。

2. Undefined 类型

Undefined 类型只有一个值，就是特殊值 undefined, 当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值

```js
let message; 
console.log(message == undefined); // true 

// 包含 undefined 值的变量跟未定义变量是有区别的
let message; // 这个变量被声明了，只是值为 undefined
// 确保没有声明过这个变量
// let age 
console.log(message); // "undefined" 
console.log(age); // 报错
```

3. Null 类型

Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回"object"的原因

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用

```js
// undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等
console.log(null == undefined); // true 

// 永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量
```

