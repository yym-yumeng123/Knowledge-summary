## UDP

> 不需要在正式传递数据之前先连接起双方。然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便

1. UDP 协议是面向无连接的
   - 不需要和 TCP 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了
   - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
   - 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
2. 不可靠性
   - 不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠
3. 高效

   - 正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达
   - UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。

4. 传输方式
   - UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。

## TCP

> TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效

不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议

1. 建立连接三次握手

- 第一次握手: 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。
- 第二次握手: 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。
- 第三次握手: 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功

2. 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接

- 为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

3. 断开链接四次握手

- 第一次握手: 客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求
- 第二次握手: B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。
- 第三次握手: B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
- 第四次握手: A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态, 若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态

---

## HTTP & TSL

- `副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。`
- 幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上`资源的状态一致`

---

1. http 请求由三部分组成: `请求行 首部 实体`
   - 请求行 `GET /images/log.gif HTTP/1.1`
2. `Post Get 区别`
   - Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册
   - Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的
   - URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的
   - Post 支持更多的编码类型且不对数据类型限制
3. `HTTP首部` 首部分为请求首部和响应首部，并且部分首部两种通用

- 通用首部
  - `Cache-control` 控制缓存
  - `Connection` 浏览器想要使用的连接类型: `keep-alive`
  - `Date` 创建报文时间
  - `Transfer-Encoding` 传输编码方式
- 请求首部
  - `Accept: `能正确接受的每次类型
  - `Accept-charset: ` 能正确接受的字符集
  - `Accept-Encoding: ` 能正确接收的编码格式列表
  - `Accept-Language: ` 能正确接受的语言列表
  - `User-Agent: ` 客户端信息
  - `Proxy-Authorization: `向代理服务器发送验证信息
  - `TE` 传输编码方式
- 响应首部
  - `Accept-Ranges: `是否支持某些种类的范围
  - `Age: ` 资源在代理缓存中的时间
  - `Etag: ` 资源标识
  - `Location: `客户端重定向到某个 URL
- 实体首部
  - `Allow: ` 资源的正确请求方式
  - `Content-Encoding` 内容的编码格式
  - `Content-Language: `内容使用的语言
  - `Content-type: ` 内容的媒体类型
  - `Expires: `内容的过期时间
  - `Last-Modified: `内容的最后修改时间

4. 常见状态码
   - 2xx 代表成功
     - `200 ok 请求成功`
     - `204 no content` 请求成功, 但没有数据返回
     - `206 partial content` 范围请求
   - 3xx 重定向
     - `301 永久性重定向` 资源被分配到新的`URL`
     - `302 临时性重定向` 资源临时被分配到新的 URI
     - `303` 资源存在另一个 URL, 使用 GET 获取资源
     - `304` 服务器允许访问资源, 但因发生请求为满足条件的情况
   - 4xx 客户端错误
     - `400 bad request` 请求存在语法错误
     - `401 ` 请求需要通过 http 认证
     - `403` 请求访问资源被拒绝
     - `404` 服务器上找不到资源
   - 5xx 服务端错误
     - `500` 服务器端在执行请求时发生了错误
     - `501` 服务器不支持当前请求的某个功能
     - `503` 服务器处于停机维护, 无法处理请求

## HTTP2

在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度

1. 二进制传输

HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码

2. 多路复用

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

3. Header 压缩

在 HTTP/1 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。

在 HTTP /2 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

4. 服务端 Push

在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源。

## 输入 URL 页面渲染的整个流程

1. 输入 URL, 会进行 URL 解析, DNS 查询, DNS 的作用就是通过域名查询到具体的 IP
   - 操作系统会首先在本地缓存中查询 IP
   - 没有的话会去系统配置的 DNS 服务器中查询
   - 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
   - 然后去该服务器查询 google 这个二级域名
   - 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP
2. TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。

3. 浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错

4. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

5. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。

6. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

7. Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了
