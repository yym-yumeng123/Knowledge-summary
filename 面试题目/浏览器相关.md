## 事件机制

**事件触发的三个阶段:**

- `window` 往事件触发处传播, 遇到注册的捕获事件会触发
- 传播到事件触发处触发注册的事件
- 从事件触发处往 `window` 传播, 遇到注册的冒泡事件会触发

**注册事件: addEventListener**

```js
node.addEventListener(
  "click",
  function (event) {
    // 阻止冒泡
    event.stopPropagation()
  },
  false
)
```

**事件代理**

- 如果子节点是动态生成的, 注册事件应该在父元素上

```js
<ul id="ul">
	<li>1</li>
    <li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ul>
<script>
	let ul = document.querySelector('#ul')
	ul.addEventListener('click', (event) => {
		console.log(event.target);
	})
</script>
```

## 跨域

- 因为浏览器出于安全考虑，有`同源策略`。也就是说，如果`协议、域名或者端口`有一个不同就是跨域，Ajax 请求会失败
- 主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求

**JSONP**
JSONP 的原理很简单，就是利用 `<script> 标签没有跨域限制的漏洞。通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时`

```js
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

**CORS**

- CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现

- 服务端设置 `Access-Control-Allow-Origin` 就可以开启 CORS

**document.domain**

- 该方式只能用于`二级域名相同的情况下`，比如 a.test.com 和 b.test.com 适用于该方式。
- 只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

**postMessage**

- 方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage("message", "http://test.com")
// 接收消息端
var mc = new MessageChannel()
mc.addEventListener("message", (event) => {
  var origin = event.origin || event.originalEvent.origin
  if (origin === "http://test.com") {
    console.log("验证通过")
  }
})
```

## 存储

1. `cookie`
   - 一般有服务器生成, 可以设置过期时间; 4k; 每次携带在请求 `header` 中
   - 应该将值加密, 不适用明文
   - `http-only`, 不能通过 JS 访问 `Cookie`, 减少 `XSS` 攻击
   - `secure` 只能在 `https` 协议携带
2. `LocalStorage`
   - 除非被清理,否则一直存在; 5M; 不参与通信
3. `SessionStorage`
   - 页面关闭就清理; 5M; 不参与通信
4. `indexDB`
   - 除非被清理,否则一直存在; 无限; 不参与通信

**Service Worker**

`Service Worker` 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Service Worker 实现缓存功能一般分为三个步骤：`首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据`。以下是这个步骤的实现：

```js
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register("sw.js")
    .then(function (registration) {
      console.log("service worker 注册成功")
    })
    .catch(function (err) {
      console.log("servcie worker 注册失败")
    })
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener("install", (e) => {
  e.waitUntil(
    caches.open("my-cache").then(function (cache) {
      return cache.addAll(["./index.html", "./index.js"])
    })
  )
})

// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener("fetch", (e) => {
  e.respondWith(
    caches.match(e.request).then(function (response) {
      if (response) {
        return response
      }
      console.log("fetch source")
    })
  )
})
```

## 浏览器缓存机制

1. 缓存位置: 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络
   - `Service Worker`
   - `Memory Cache` : 也就是内存中的缓存
     - 对于大文件来说，大概率是不存储在内存中的，反之优先
     - 当前系统内存使用率高的话，文件优先存储进硬盘
   - `Disk Cache`: 存储在硬盘中的缓存
     - 比之 Memory Cache 胜在容量和存储时效性上
     - 并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据
   - `Push cache`
     - Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放
   - `网络请求`


2. 缓存策略

> 浏览器缓存策略分为两种：`强缓存和协商缓存`，并且缓存策略都是通过设置 HTTP Header 来实现的

- `强缓存: `通过设置两种 `HTTP Header 实现：Expires 和 Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200
  - `Expires`  过期时间: `Expires 是 HTTP/1` 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效
  - `Cache-Control: `  `Cache-control: max-age=30`; `Cache-Control 出现于 HTTP/1.1`，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求

- `协商缓存: ` 如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 `HTTP Header 实现：Last-Modified 和 ETag`
  - `Last-Modified 和 If-Modified-Since:` Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。
  - `ETag 和 If-None-Match: ` ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。

- `如果什么缓存策略都没设置，那么浏览器会怎么处理？`
   - 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。