> 如果说 TypeScript 是一门对类型进行编程的语言, 那么泛型就是这门语言里的(函数)参数

### 类型别名中的泛型

比如类型别名如果声明了泛型坑位, 那其实就等价于一个接受参数的函数

```ts
// 本质是一个函数, T是它的变量, 返回值是一个包含 T 的联合类型
type Factory<T> = T | number | string;

// ==>

function Factory(typeArg) {
  return [typeArg, number, string];
}
```

类型别名中的泛型大多是用来进行工具类型的封装

```ts
// 将一个对象类型所有属性置为 string
type Stringify<T> = {
  [K in keyof T]: string;
};

// 对类型进行完全复制
type Clone<T> = {
  [K in keyof T]: T[K];
};
```

一个 TS 内置工具类型的实现

```ts
// 将对象类型都变成可选
type MyPartial<T> = {
  [P in keyof T]?: T[P];
};

interface IFoo {
  prop1: string;
  prop2: number;
  prop3: boolean;
  prop4: () => void;
}

type PartialIFoo = Partial<IFoo>;

// 等价于
interface PartialIFoo {
  prop1?: string;
  prop2?: number;
  prop3?: boolean;
  prop4?: () => void;
}
```

类型别名与泛型的结合中, 除了映射类型, 索引类型等类型工具以外, 还有一个非常重要的工具: 条件类型

```ts
type IsEqual<T> = T extends true ? 1 : 2;

type A = IsEqual<true>; // 1
type B = IsEqual<false>; // 2
type C = IsEqual<"yym">; // 2
```

在条件类型参与的情况下, 通常泛型会被作为 条件类型中的判断条件(T extends Condition, Type extneds T) 以及返回值, 这也是我们筛选类型需要依赖的能力之一
