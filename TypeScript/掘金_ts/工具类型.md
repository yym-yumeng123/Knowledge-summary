> 工具类型和类型编程并不完全等价, 它是类型编程最常见的一种表现形式, 类型编程的复杂度也体现在函数的重载与泛型约束方面。

### 属性修饰工具类型

> 主要使用 属性修饰, 映射类型与索引类型相关(索引类型签名, 索引类型访问, 索引类型查询)

```ts
// ? 可选
// 也可以 +? 来显示表示添加可选标记
type Partial<T> = {
    [P in keyof T]?: T[P];
};

// -? 原本属性上有 ? 这个标记,移除
type Required<T> = {
    [P in keyof T]-?: T[P];
};

type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};
```

可选标记不等于修改此属性类型为 `原类型 | undefined` 

```ts
interface Foo {
  optional: string | undefined;
  required: string;
}

// 类型 "{ required: string; }" 中缺少属性 "optional"，但类型 "Foo" 中需要该属性。
const foo1: Foo = {
  required: '1',
};

const foo2: Foo = {
  required: '1',
  optional: undefined
};
```

因为对于结构声明来说, 一个属性是否必须提供仅取决于 `是否携带可选标记`, 即使使用 never 也无法标记这个属性为可选

```ts
interface Foo {
  optional: never;
  required: string;
}

const foo: Foo = {
  required: '1',
  // 不能将类型“string”分配给类型“never”。
  optional: '',
};

```

```ts
type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
```

### 结构工具类型

这一部分工具类型主要使用 **条件类型以及映射类型. 索引类型**
结构类型工具其实可以分为两类: 结构声明和结构处理

```ts
// K extends keyof any 即为键的类型
// extends keyof any => 传入的 K 可以是单个类型, 也可以是联合类型, T 即为属性的类型
type Record<K extends keyof any, T> = {
  [P in K]: T;
};

interface EmployeeType {
  id: number;
  fullname: string;
  role: string;
}

// 键名均为字符串, 键值类型未知
type Record1 = MyRecord<string, unknown>;
// 键名均为字符串, 键值类型任意
type Record2 = MyRecord<string, any>;
// 键名为字符串或数字, 键值类型任意
type Record3 = MyRecord<string | number, any>;
type Record4 = MyRecord<number, EmployeeType>;

let employees: Record4 = {
  0: { id: 1, fullname: "John Doe", role: "Designer" },
  1: { id: 2, fullname: "Ibrahima Fall", role: "Developer" },
  2: { id: 3, fullname: "Sara Duckson", role: "Developer" },
};
```

```ts
type petsGroup = 'dog' | 'cat' | 'fish';
interface IPetInfo {
    name:string,
    age:number,
}

type IPets = Record<petsGroup | 'otherAnamial', IPetInfo>;

const animalsInfo:IPets = {
    dog:{
        name:'dogName',
        age:2
    },
    cat:{
        name:'catName',
        age:3
    },
    fish:{
        name:'fishName',
        age:5
    },
    otherAnamial:{
        name:'otherAnamialName',
        age:10
    }
}
```

类似的结构声明工具类型

```ts
// Dictionary （字典）结构只需要一个作为属性类型的泛型参数即可
type Dictionary<T> = {
  [index: string]: T;
};

type NumericDictionary<T> = {
  [index: number]: T;
};
```

Pick Omit

```ts
// T 即是我们会进行结构处理的原类型（一般是对象类型）
// K 则被约束为 T 类型的键名联合类型
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

interface Foo {
  name: string;
  age: number;
  job: JobUnionType;
}
// 联合类型的成员会被依次映射，并通过索引类型访问来获取到它们原本的类型
type PickedFoo = Pick<Foo, "name" | "age">
```

Pick 是保留这些传入的键, Omit 则是移除这些传入的键
```ts
// 在关键位置使用一个相反操作来实现反向, 反向工具类型基于正向工具类型实现
// Exclude<keyof T, K> 其实就是 T 的键名联合类型中剔除了 K 的部分，将其作为 Pick 的键名
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>


// Exclude<A, B> 的结果就是联合类型 A 中不存在于 B 中的部分
type Tmp1 = Exclude<1, 2>; // 1
type Tmp2 = Exclude<1 | 2, 2>; // 1
type Tmp3 = Exclude<1 | 2 | 3, 2 | 3>; // 1
type Tmp4 = Exclude<1 | 2 | 3, 2 | 4>; // 1 | 3
```