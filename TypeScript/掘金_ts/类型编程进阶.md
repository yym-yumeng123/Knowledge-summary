### 属性修饰进阶

- 深层的属性修饰
- 基于已知属性的部分修饰, 以及基于属性类型的部分修饰

首先是深层属性修饰

```ts
type PromiseValue<T> = T extends Promise<infer V> ? PromiseValue<V> : T;
```

我们只是在条件类型成立是, 再次调用了这个工具类型而已. 在某一次递归到条件类型不成立时, 就会直接返回这个值, 对于 `Partial Required` 可以这样处理

```ts
type DeepPartial<T extends object> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

export type DeepPartial<T extends object> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

export type DeepRequired<T extends object> = {
  [K in keyof T]-?: T[K] extends object ? DeepRequired<T[K]> : T[K];
};

// 也可以记作 DeepImmutable
export type DeepReadonly<T extends object> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

export type DeepMutable<T extends object> = {
  -readonly [K in keyof T]: T[K] extends object ? DeepMutable<T[K]> : T[K];
};
```

之前存在一个从联合类型中剔除 `null | undefined` 的工具类型 NonNullable

```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```

在对象结构中我们也常生命类型 `string | null` 的形式, 代表了: 这里有值, 但可能是空值. 此时, 我们可以将其等价为一种属性修饰(Nullable属性), 前面则是`Optional/Readonly属性`,

```ts
type DeepNonNullable<T extends object> = {
  [K in keyof T]: T[K] extends object
    ? DeepNonNullable<T[K]>
    : NonNullable<T[K]>;
};

```


基于已知属性的不部分修饰

- 拆分对象结构，那不就是内置工具类型一节中讲到的结构工具类型，即 Pick 与 Omit？
- 三个属性的对象全部变为可选，那不就是属性修饰？岂不是可以直接用上面刚学到的递归属性修饰？
- 组合两个对象类型，也就意味着得到一个同时符合这两个对象类型的新结构，那不就是交叉类型？

**将复杂的工具类型，拆解为由基础工具类型、类型工具的组合**

```ts
/**
 * @des 讲一个对象的部分属性标记为可选
 * T: 需要处理的对象类型
 * K: 需要标记为可选的属性, 必须为 T 内部的属性, 对象属性组成的字面量联合类型
 */
type MarkPropsAsOptional<
  T extends object,
  K extends keyof T = keyof T
> = Partial<Pick<T, K>> & Omit<T, K>;

type MarkPropsAsOptionalStruct = MarkPropsAsOptional<
  {
    foo: string;
    bar: number;
    baz: boolean;
  },
  "bar"
>;

export type MarkPropsAsRequired<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Required<Pick<T, K>>>;

export type MarkPropsAsReadonly<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Readonly<Pick<T, K>>>;

export type MarkPropsAsMutable<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Mutable<Pick<T, K>>>;

export type MarkPropsAsNullable<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Nullable<Pick<T, K>>>;

export type MarkPropsAsNonNullable<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & NonNullable<Pick<T, K>>>;

```

### 结构工具类型进阶

- 基于键值类型的 Pick 和 Omit
- 子结构的互斥处理


**基于键值类型的 Pick 和 Omit**

基于期望的类型拿到所有此类型的属性名, 如想 Pick 出所有函数类型的值, 那就要先拿到所有的函数类型属性名. 先来一个 FunctionKeys 工具类型


```ts
type FunctionStruct = (...args: any[]) => any;

type FunctionKeys<T extends object> = {
  [K in keyof T]: T[K] extends FunctionStruct ? K : never;
}[keyof T];
```

`{}[keyof T]` 这个写法第一次见, 拆开来看: `{ [K in keyof T]: T[K] extends FuncStruct ? K : never; }` 为何在条件类型成立时它返回了键名 K，而非索引类型查询 T[K] ？

```ts
type Tmp<T extends object> = {
  [K in keyof T]: T[K] extends FunctionStruct ? K : never;
};

type Res = Tmp<{
  foo: () => void;
  bar: () => number;
  baz: number;
}>;

type ResEqual = {
  foo: "foo";
  bar: "bar";
  baz: never;
};

```

获得了一个 **属性名-属性名字面量类型** 的结构, 对于fw函数类型的属性, 其值为 never, 然后我们加上 [keyof  T] 这一索引类型查询 + keyof 操作符的组合

```ts
type WhatWeWillGet = Res[keyof Res]; // 'foo' | 'bar'
```

神奇的获得了所有函数类型的参数, 当索引类型查询中使用一个联合类型时, 会使用类似分布式条件类型的方式, 将这个联合类型成员依次访问, 然后组合起来

```ts
type WhatWeWillGet = Res[keyof Res]; // 'foo' | 'bar'
type WhatWillWeGetEqual1 = Res["foo" | "bar" | "baz"];
type WhatWillWeGetEqual2 = Res["foo"] | Res["bar"] | Res["baz"];
type WhatWillWeGetEqual3 = "foo" | "bar" | never;
```

如果希望抽象“基于键值类型查找属性”名这么个逻辑，我们就需要对 FunctionKeys 的逻辑进行封装，即将预期类型也作为泛型参数，由外部传入：

```ts
type PickByValueType<T extends object, valueType> = Pick<
  T,
  ExpectedPropKeys<T, valueType>
>;

// {
//   foo: string;
// }
type PickResult1 = PickByValueType<{ foo: string; bar: number }, string>;

// {
//   foo: string;
//   bar: number;
// }
type PickResult2 = PickByValueType<
  { foo: string; bar: number; baz: boolean },
  string | number
>;
```

```ts
type FilteredPropKeys<T extends object, ValueType> = {
  [Key in keyof T]-?: T[Key] extends ValueType ? never : Key;
}[keyof T];

type OmitByValueType<T extends object, ValueType> = Pick<
  T,
  FilteredPropKeys<T, ValueType>
>;

type OmitRes1 = OmitByValueType<{ foo: string; bar: number }, string>;
type OmitRes2 = OmitByValueType<
  { foo: string; bar: number; baz: boolean },
  string | number
>;
```

把 ExpectedPropKeys 和 FilteredPropKeys 合并在一起

```ts
type Conditional<Value, Condition, Resloved, Rejectd> = Value extends Condition
  ? Resloved
  : Rejectd;

type ValueTypeFilter<T extends object, ValueType, Positive extends boolean> = {
  [Key in keyof T]-?: T[Key] extends ValueType
    ? Conditional<Positive, true, Key, never>
    : Conditional<Positive, true, never, Key>;
}[keyof T];

type PickByValueType1<T extends object, ValueType> = Pick<
  T,
  ValueTypeFilter<T, ValueType, true>
>;

type OmitByValueType1<T extends object, ValueType> = Pick<
  T,
  ValueTypeFilter<T, ValueType, false>
>;
```