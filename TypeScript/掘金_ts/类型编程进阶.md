### 属性修饰进阶

- 深层的属性修饰
- 基于已知属性的部分修饰, 以及基于属性类型的部分修饰

首先是深层属性修饰

```ts
type PromiseValue<T> = T extends Promise<infer V> ? PromiseValue<V> : T;
```

我们只是在条件类型成立是, 再次调用了这个工具类型而已. 在某一次递归到条件类型不成立时, 就会直接返回这个值, 对于 `Partial Required` 可以这样处理

```ts
type DeepPartial<T extends object> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

export type DeepPartial<T extends object> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

export type DeepRequired<T extends object> = {
  [K in keyof T]-?: T[K] extends object ? DeepRequired<T[K]> : T[K];
};

// 也可以记作 DeepImmutable
export type DeepReadonly<T extends object> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

export type DeepMutable<T extends object> = {
  -readonly [K in keyof T]: T[K] extends object ? DeepMutable<T[K]> : T[K];
};
```

之前存在一个从联合类型中剔除 `null | undefined` 的工具类型 NonNullable

```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```

在对象结构中我们也常生命类型 `string | null` 的形式, 代表了: 这里有值, 但可能是空值. 此时, 我们可以将其等价为一种属性修饰(Nullable属性), 前面则是`Optional/Readonly属性`,

```ts
type DeepNonNullable<T extends object> = {
  [K in keyof T]: T[K] extends object
    ? DeepNonNullable<T[K]>
    : NonNullable<T[K]>;
};

```


基于已知属性的不部分修饰

- 拆分对象结构，那不就是内置工具类型一节中讲到的结构工具类型，即 Pick 与 Omit？
- 三个属性的对象全部变为可选，那不就是属性修饰？岂不是可以直接用上面刚学到的递归属性修饰？
- 组合两个对象类型，也就意味着得到一个同时符合这两个对象类型的新结构，那不就是交叉类型？

**将复杂的工具类型，拆解为由基础工具类型、类型工具的组合**

```ts
/**
 * @des 讲一个对象的部分属性标记为可选
 * T: 需要处理的对象类型
 * K: 需要标记为可选的属性, 必须为 T 内部的属性, 对象属性组成的字面量联合类型
 */
type MarkPropsAsOptional<
  T extends object,
  K extends keyof T = keyof T
> = Partial<Pick<T, K>> & Omit<T, K>;

type MarkPropsAsOptionalStruct = MarkPropsAsOptional<
  {
    foo: string;
    bar: number;
    baz: boolean;
  },
  "bar"
>;

export type MarkPropsAsRequired<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Required<Pick<T, K>>>;

export type MarkPropsAsReadonly<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Readonly<Pick<T, K>>>;

export type MarkPropsAsMutable<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Mutable<Pick<T, K>>>;

export type MarkPropsAsNullable<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & Nullable<Pick<T, K>>>;

export type MarkPropsAsNonNullable<
  T extends object,
  K extends keyof T = keyof T
> = Flatten<Omit<T, K> & NonNullable<Pick<T, K>>>;

```

### 结构工具类型进阶