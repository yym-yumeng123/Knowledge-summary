### null 与 undefined

js 中

- null => 这里有值, 但是个空值
- undefined => 这里没有值

ts 中, null 和 undefined 类型都是有具体意义的类型, 作为类型时, 表示的是一个有意义的具体类型值

- 在没有开启 `strictNullChecks` 下, **被视作其他类型的子类型**, string 类型会被认为包含了 null 与 undefined 类型

```ts
const tmp1: null = null;
const tmp3: string = null;
```

### void

js 中

```js
// void(0) 等价于 void 0，即 void expression 的语法
<a href="javascript:void(0)">清除缓存</a>;

void (function iife() {
  console.log("Invoked!");
})();
```

ts 中

这里的 void 用于描述一个**内部没有 return 语句**，或者**没有显式 return 一个值的函数的返回值**

```js
// 返回值类型隐式推导为 void
function func1() {}
function func2() {
  return;
}

// 返回值类型 显式为 undefined
function func3() {
  return undefined;
}
```

虽然 func3 的返回值类型会被推导为 undefined，但是你仍然可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”

可以认为 void 表示一个空类型, 而 null 与 undefined 都是一个具有意义的实际类型, 而 undefined 能够被赋值给 void 类型的变量,就像在 JavaScript 中一个没有返回值的函数会默认返回一个 undefined 。null 类型也可以，但需要在关闭 strictNullChecks 配置的情况下才能成立

### 数组的类型标注

```ts
// 两种方式
const arr1: string[] = [];
const arr2: Array<string> = [];
```

数组是我们在日常开发大量使用的数据结构，但在某些情况下，使用 **元组（Tuple）** 来代替数组要更加妥当，比如一个数组中只存放固定长度的变量，但我们进行了超出长度地访问：

```ts
const arr3: string[] = ["y1", "y2", "y3"];
console.log(arr3[599]); // 不报错
```

```ts
// Tuple
const arr4: [string, string, string] = ["y1", "y2", "y3"];
console.log("arr4[599]", arr4[599]); // 长度为 "3" 的元组类型 "[string, string, string]" 在索引 "599" 处没有元素
```

除了同类型的元素以外，元组内部也可以声明多个与其位置强绑定的，不同类型的元素

```ts
const arr5: [string, number, boolean] = ["linbudu", 599, true];
```

元组也支持了在某一个位置上的可选成员

```ts
const arr6: [string, number?, boolean?] = ["linbudu"];
// const arr6: [string, number?, boolean?] = ['linbudu', , ,];
```

对于标记为可选的成员，在 **--strictNullCheckes** 配置下会被视为一个 string | undefined 的类型。此时元组的长度属性也会发生变化，比如上面的元组 arr6 ，其长度的类型为 1 | 2 | 3

```ts
// 元组的长度可能为 1、2、3。
type TupleLength = typeof arr6.length; // 1 | 2 | 3
```

对于 [string, number, boolean]来说，你并不能直接知道这三个元素都代表什么，还不如使用对象的形式, 具名元组（Labeled Tuple Elements）的支持

```ts
const arr7: [name1: string, age1: number, male1?: boolean] = ["yym", 16, true];
```

实际上除了显式地越界访问，还可能存在隐式地越界访问，如通过解构赋值的形式

```js
const arr1: string[] = [];
const [ele1, ele2, ...rest] = arr1;
```

### 对象的类型标注
