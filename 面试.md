## 数据类型

- 原始类型有六种 `string number boolean undefined null symbol`, 原始类型存储的都是值
- 对象类型只有 `Object`, 对象类型存储的是地址(引用), 当你创建一个对象类型, 计算机会在内存中开辟一个空间来存放值, 这个空间会有一个地址(指针), 我们可以找到它

```js
const a = [] // 假设地址为 #000, name在地址 #000 的位置放了值 []

const b = a // 复制的是原本变量的地址
b.push(1)

a // [1]
b // [1]
```

```js
//  函数参数是对象
function test(person) {
  person.age = 26
  person = {
    name: "John",
    age: 30,
  }
  return person
}

const p1 = {
  name: "Jack",
  age: 25,
}

const p2 = test(p1)
console.log(p1) // { name: 'Jack', age: 26 }
console.log(p2) // { name: 'John', age: 30 }

// 解析
// 1. 函数传参是传递对象指针的副本
// 2. p1 赋值 给 person, person 修改了 age
// 3. person 重新赋值, 给了一个新地址, 和 p1 没有关系, 返回了 person, 是 p2 
```


## typeof vs instanceof
- `typeof`
```js
// typeof 对原始数据类型, 除了 null 都显示正确的的类型
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'

// 对于对象
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```
- `instanceof` 是通过原型链来判断的
```js
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

// 对于原始类型来说，你想直接通过 instanceof 来判断类型是不行的
var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true

[] instanceof Array // true
```

```js
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

## 类型转换
在 `JS` 中, 类型转换只有三种情况:
- 转换为`Boolean`
- 转换为 `Number`
- 转换为 `String`

```js
number -> boolean           : 除了 `0 -0 NaN` 都是 true
string -> boolean           : 除了 `空字符串` 都是 true
undefined null -> boolean   : false
引用类型 -> boolean           : true
number -> 字符串              : 5 => '5'
Boolean 函数 Symbol -> 字符串 : 'true'
数组 -> 字符串                 : [1, 2] => '1, 2'
对象 -> 字符串                 : '[object, object]'
string -> 数字                : '1' => 1 'a' => NaN
数组 -> 数字                  : 空数组 => 0, 存在一个元素为数字 => 数字,其他 NaN
null -> 数字                  : 0
除了数组的引用类型 -> 数字        : NaN
Symbol -> 数字 : NaN          : 抛错
```
在条件判断时，除了 `undefined， null， false， NaN， ''， 0， -0`，其他所有值都转为 true，包括所有对象

---

- 四则运算
```js
// 运算中其中一方为字符串，那么就会把另一方也转换为字符串
// 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串
1 + '1' // 11
true + true // 2
4 + [1, 2, 3] // 41,2,3

'a' + + 'b' // -> "aNaN"
```

```js
// 除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
```

## this
- 如何正确判断 this？箭头函数的 this 是什么？

```js
// 函数调用的场景

// 普通函数调用
function foo() {
  console.log(this.a) // window.a
}
var a = 1
foo()

// 对象调用
const obj = {
  a: 2,
  foo: foo
}
obj.foo() // obj.foo.call(obj) 谁调用, 谁是this

// 构造函数调用
const c = new foo() // this 就是 c
```
- 箭头函数没有 `this`, 箭头函数中的 `this` 只取决包裹箭头函数的第一个普通函数的 `this`
- 对箭头函数使用 `bind` 这类函数是无效的
```js
// 箭头函数的 this

function a() {
  // this 的环境
  return () => {
    return () => {
      console.log(this)
    }
  }
}
console.log(a()()())
```
- `bind apply call`
```js
let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // window

let a = { name: 'yck' }
function foo() {
  console.log(this.name)
}
foo.bind(a)() // => 'yck'
```

- `new` 的方式优先级最高，接下来是 `bind` 这些函数，然后是 `obj.foo()` 这种调用方式，最后是 `foo` 这种调用方式，同时，箭头函数的 `this` 一旦被绑定，就不会再被任何方式所改变