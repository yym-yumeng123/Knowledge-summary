### 树

> 树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图

1. 树的相关术语

> 一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点

![树](https://upload-images.jianshu.io/upload_images/5983146-622ae748070d13f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

根据上图:

- 位于树顶部的节点叫做`根节点(11)`
- 树中的每个元素都叫作节点，节点分为`内部节点和外部节点`
  - 至少有一个子节点的节点称为内部节点（7、5、9、15、13 和 20 是内部节点）
  - 没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18 和 25 是叶节点）
- 一个节点可以有祖先和后代
  - 一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等, 节点 5 的祖先有节点 7 和节点 11，
  - 一个节点的后代包括子节点、孙子节点、曾孙节点等, 节点 5 后代有节点 3 和节点 6
- 树的另一个术语是`子树`
  - 子树由节点和它的后代构成。例如，节点 13、12 和 14 构成了上图中树的一棵子树
- 节点的一个属性是`深度`
  - 节点的深度取决于它的祖先节点的数量。比如，节点 3 有 3 个祖先节点（5、7 和 11），它的深度为 3
- 树的高度取决于所有`节点深度的最大值`
  - 一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。上图中的树的高度为 3（最大高度已在图中表示——第 3 层）

2. 二叉树和二叉搜索树

> 二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点, 二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。上一节的图中就展现了一棵二叉搜索树

3. 创建二叉搜索树`(BinarySearchTree)`类

![二叉搜索树数据结构组织方式](https://upload-images.jianshu.io/upload_images/5983146-003e90c1805bac8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上图展现了二叉搜索树数据结构的组织方式, 先来创建 Node 类来表示二叉搜索树中的每个节点

> 和链表一样, 我们通过指针(引用)来表示节点之间的关系, 树也是用两个指针, 但一个指向`左侧`子节点, 另一个指向`右侧`子节点, 不同于在之前的章节中将节点本身称作节点或项，我们将会称其为键

```js
class Node {
  constructor(key) {
    this.key = key;
    this.left = null;
    this.right = null;
  }
}
```

声明一个 `BinarySearchTree` 类的基本结构

```js
class BinarySearchTree {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn;
    // 将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是 head，而是 root
    this.root = null;
  }
}
```

4. 实现一些方法

   - `insert(key): `想树中插入一个新的键
   - `search(key): `向树中查找一个键, 如果节点存在, 返回 true, 否则返回 false
   - `inOrderTraverse(): `通过中序遍历方式遍历所有节点
   - `preOrderTraverse(): `通过先序遍历方式遍历所有节点
   - `postOrderTravsese(): `通过后序遍历方式遍历所有节点
   - `min(): `返回树中的最小值/键
   - `max(): `返回树中的最大的值/键
   - `remove(key): `从树中移除某个键

5. 向二叉搜索树插入一个值

```js
class BinarySearchTree {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn;
    // 将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是 head，而是 root
    this.root = null;
  }

  //
  // 如果树非空，需要找到插入新节点的位置。因此，在调用 insertNode 方法时要通过参数传入树的根节点和要插入的节点
  insertNode(node, key) {
    // 如果新节点的键小于当前节点的键
    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
      // 检查当前节点的左侧子节点, 如果它没有左侧子节点
      if (node.left == null) {
        // 在那里插入新的节点
        node.left = new Node(key);

        // 有左侧子节点，需要通过递归调用 insertNode方法
      } else {
        this.insertNode(node.left, key);
      }
    } else {
      // 节点的键比当前节点的键大，同时当前节点没有右侧子节点
      if (node.right == null) {
        node.right = new Node(key);

        // 有右侧子节点，同样需要递归调用 insertNode 方法
      } else {
        this.insertNode(node.right, key);
      }
    }
  }

  insert(key) {
    // 尝试插入的树节点是否为第一个节点
    if (this.root == null) {
      // 创建一个 Node 类的实例并将它赋值给 root 属性来将 root 指向这个新节点, 左指针和右指针的值会由构造函数自动设置为 null
      this.root = new Node(key);
    } else {
      this.insertNode(this.root, key);
    }
  }
}

tree.insert(7);
tree.insert(15);
tree.insert(5);
tree.insert(3);
tree.insert(9);
tree.insert(8);
tree.insert(10);
tree.insert(13);
tree.insert(12);
tree.insert(14);
tree.insert(20);
tree.insert(18);
tree.insert(25);
```

![insert](https://upload-images.jianshu.io/upload_images/5983146-c25fbcd9605122d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

6. 树的遍历之中序遍历

> 遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程, 访问树的所有节点有三种方式：中序、先序和后序

**中序遍历**

> 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点

```js
class BinarySearchTree {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn;
    // 将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是 head，而是 root
    this.root = null;
  }

  /**
   * 中序遍历
   * @param {接收一个回调函数作为参数} callback
   */
  inOrderTraverse(callback) {
    // 定义我们对遍历到的每个节点进行的操作
    this.inOrderTraverseNode(this.root, callback);
  }

  // 辅助方法，来接收一个节点和对应的回调函数作为参数
  inOrderTraverseNode(node, callback) {
    // 首先要检查以参数形式传入的节点是否为 null, 停止递归继续执行的判断条件
    if (node != null) {
      // 递归调用相同的函数来访问左侧子节点, 再访问右侧子节点
      this.inOrderTraverseNode(node.left, callback);
      callback(node.key);
      this.inOrderTraverseNode(node.right, callback);
    }
  }
}

const printNode = (value) => console.log(value); // {6}
tree.inOrderTraverse(printNode); // {7}
```

![中序遍历](https://upload-images.jianshu.io/upload_images/5983146-fc9e142c69d8a8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

7. 树的遍历之先序遍历

> 先序遍历是以优先于后代节点的顺序访问每个节点的, 先序遍历的一种应用是打印一个结构化的文档
