### 链表数据结构

> 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下

```
head -> value | next -> value | next -> value | next -> undefined
```

> 相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意, 想要访问链表中的一个元素, 需要从起点(表头) 开始迭代链表直到找到所需的元素, 现实生活中: 比如火车类似链表的结构

1. 创建链表

理解了什么是链表, 开始实现我们的数据结构

```js
// 骨架
function defaultEquals(a, b) {
  return a === b;
}

class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0; // 存储链表中的元素数量
    // 数据结构是动态的，我们还需要将第一个元素的引用保存下来。我们可以用一个叫作head 的元素保存引用
    this.head = undefined;
    // 要比较链表中的元素是否相等，我们需要使用一个内部调用的函数，名为 equalsFn
    this.equalsFn = equalsFn;
  }
}
```

要表示链表中的第一个以及其他元素, 需要一个助手类, 叫做 `Node`

```js
// Node类表示我们想要添加到链表中的项。
class Node {
  constructor(element) {
    // 该属性表示要加入链表元素的值；以及一个 next 属性，该属性是指向链表中下一个元素的指针
    this.element = element;
    this.next = undefined;
  }
}
```

2. 链表类的方法

   - `push(element): `向链表尾部添加一个新元素
   - `insert(element, position): ` 向链表特定位置插入一个新元素
   - `getElementAt(): `返回链表中特定位置的元素, 如果链表中不存在这样的元素, 返回 undefined
   - `remove(element): `从链表中移除一个元素
   - `indexOf(element): `返回元素在链表中的索引, 如果链表中没有该元素返回 -1.
   - `removeAt(position): `从链表的特定位置移除一个元素
   - `isEmpty(): `链表长度大于 0 返回 false
   - `size(): `返回链表的长度
   - `toString(): `返回整个链表的字符串, 由于列表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。

3. 实现链表类的 `push` 方法

   - 链表最后一个节点的下一个元素始终是 undefined 或 null
   - 链表为空, 添加的是第一个元素, 链表不为空, 向其追加元素

   ![空链表push](https://upload-images.jianshu.io/upload_images/5983146-9699a904409eb6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
   ![非空链表](https://upload-images.jianshu.io/upload_images/5983146-59b99f05c4848bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```js
class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0; // 存储链表中的元素数量
    // 数据结构是动态的，我们还需要将第一个元素的引用保存下来。我们可以用一个叫作head 的元素保存引用
    this.head = undefined;
    // 要比较链表中的元素是否相等，我们需要使用一个内部调用的函数，名为 equalsFn
    this.equalsFn = equalsFn;
  }

  /**
   * 两种情景: 1. 链表为空, 添加的是第一个元素, 链表不为空, 向其追加元素
   */
  push(element) {
    // 创建 Node 项
    const node = new Node(element);
    let current;
    // 1. 如果 head 为 undefined 或者 null , 链表添加第一个元素
    if (this.head == null) {
      this.head = node;
      // 2. 不为空的链表尾部添加元素, 首先找到最后一个元素
    } else {
      current = this.head; // 只有第一个元素的引用
      while (current.next != null) {
        current = current.next;
      }
      // current.next 为 null 或者 undefined, 到达链表尾部了
      current.next = node;
    }
    this.count++;
  }
}
```

4. 实现链表类的 `removeAt` 方法

   - 要得到需要移除的元素的 index（位置），校验 index 有效性
   - 移除第一个元素 & 移除第一个元素之外的元素
   - ![移除第一个](https://upload-images.jianshu.io/upload_images/5983146-bfca460f5919c0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
   - ![移除链表](https://upload-images.jianshu.io/upload_images/5983146-95199742a64c7631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```js
class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0; // 存储链表中的元素数量
    // 数据结构是动态的，我们还需要将第一个元素的引用保存下来。我们可以用一个叫作head 的元素保存引用
    this.head = undefined;
    // 要比较链表中的元素是否相等，我们需要使用一个内部调用的函数，名为 equalsFn
    this.equalsFn = equalsFn;
  }

  removeAt(index) {
    if (index >= 0 && index < this.count) {
      // current 变量创建一个对链表中第一个元素的引用
      let current = this.head;

      // 移除第一项, 让 head 指向第二个元素
      if (index === 0) {
        this.head = current.next;
      } else {
        // 移除链表最后一个或者中间某一元素, 迭代链表的节点
        let previous;
        for (let i = 0; i < index; i++) {
          previous = current;
          // current 变量总是为对所循环列表的当前元素的引用
          current = current.next;
        }

        // 要从链表中移除当前元素，要做的就是将 previous.next 和 current.next 链接起来
        previous.next = current.next;
      }
      this.count--;
      return current.element;
    }
    return undefined;
  }
}
```

5. 循环迭代链表直到目标位置

   - remove 方法中, 迭代整个链表直到我们的目标索引 index, 很常用, 我们重构, 先实现 `getElementAt` 方法

```js
class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0; // 存储链表中的元素数量
    // 数据结构是动态的，我们还需要将第一个元素的引用保存下来。我们可以用一个叫作head 的元素保存引用
    this.head = undefined;
    // 要比较链表中的元素是否相等，我们需要使用一个内部调用的函数，名为 equalsFn
    this.equalsFn = equalsFn;
  }

  // 返回链表中特定位置的元素
  getElementAt(index) {
    // 要对传入的 index 参数进行合法性验证
    if (index >= 0 && index <= this.count) {
      // 要初始化 node 变量，该变量会从链表的第一个元素 head 开始迭代整个链表
      let current = this.head;
      for (let i = 0; i < index && current != null; i++) {
        current = current.next;
      }
      return current;
    }
    return undefined;
  }
}
```

6. 在任意位置插入元素 `insert`
   - 在第一个位置添加 & 其它位置添加
   - ![添加](https://upload-images.jianshu.io/upload_images/5983146-b896f43d5d76390f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
   - ![添加其他位置](https://upload-images.jianshu.io/upload_images/5983146-2e87ba3940918648.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```js
class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0; // 存储链表中的元素数量
    // 数据结构是动态的，我们还需要将第一个元素的引用保存下来。我们可以用一个叫作head 的元素保存引用
    this.head = undefined;
    // 要比较链表中的元素是否相等，我们需要使用一个内部调用的函数，名为 equalsFn
    this.equalsFn = equalsFn;
  }

  insert(element, index) {
    // 检查越界值
    if (index >= 0 && index <= this.count) {
      const node = new Node(element);

      // 如果在第一个位置添加
      if (index === 0) {
        const current = this.head;
        node.next = current; // 修改对应引用
        this.head = node;
      } else {
        const previours = this.getElementAt(index - 1);
        const current = previours.next;
        node.next = current;
        previours.next = node;
      }
      this.count++;
      return true;
    }
    return false;
  }
}
```

7. 实现其他所有方法
   - indexOf size isEmpty 等方法, 以及完整方法

```js
class LinkedList {
  constructor(equalsFn = defaultEquals) {
    this.count = 0; // 存储链表中的元素数量
    // 数据结构是动态的，我们还需要将第一个元素的引用保存下来。我们可以用一个叫作head 的元素保存引用
    this.head = undefined;
    // 要比较链表中的元素是否相等，我们需要使用一个内部调用的函数，名为 equalsFn
    this.equalsFn = equalsFn;
  }

  /**
   * 两种情景: 1. 链表为空, 添加的是第一个元素, 链表不为空, 向其追加元素
   */
  push(element) {
    // 创建 Node 项
    const node = new Node(element);
    let current;
    // 1. 如果 head 为 undefined 或者 null , 链表添加第一个元素
    if (this.head == null) {
      this.head = node;
      // 2. 不为空的链表尾部添加元素, 首先找到最后一个元素
    } else {
      current = this.head; // 只有第一个元素的引用
      while (current.next != null) {
        current = current.next;
      }
      // current.next 为 null 或者 undefined, 到达链表尾部了
      current.next = node;
    }
    this.count++;
  }

  removeAt(index) {
    if (index >= 0 && index < this.count) {
      // current 变量创建一个对链表中第一个元素的引用
      let current = this.head;

      // 移除第一项, 让 head 指向第二个元素
      if (index === 0) {
        this.head = current.next;
      } else {
        const previous = this.getElementAt(index - 1);
        current = previous.next;

        // 要从链表中移除当前元素，要做的就是将 previous.next 和 current.next 链接起来
        previous.next = current.next;
      }
      this.count--;
      return current.element;
    }
    return undefined;
  }

  remove(element) {
    const index = this.indexOf(element);
    return this.removeAt(index);
  }

  getElementAt(index) {
    // 要对传入的 index 参数进行合法性验证
    if (index >= 0 && index <= this.count) {
      // 要初始化 node 变量，该变量会从链表的第一个元素 head 开始迭代整个链表
      let current = this.head;
      for (let i = 0; i < index && current != null; i++) {
        current = current.next;
      }
      return current;
    }
    return undefined;
  }

  insert(element, index) {
    // 检查越界值
    if (index >= 0 && index <= this.count) {
      const node = new Node(element);

      // 如果在第一个位置添加
      if (index === 0) {
        const current = this.head;
        node.next = current; // 修改对应引用
        this.head = node;
      } else {
        const previours = this.getElementAt(index - 1);
        const current = previours.next;
        node.next = current;
        previours.next = node;
      }
      this.count++;
      return true;
    }
    return false;
  }

  // 接受元素的值, 返回元素的位置
  indexOf(element) {
    let current = this.head;
    for (let i = 0; i < this.count && current != null; i++) {
      // current 节点的元素和目标元素是否相等
      if (this.equalsFn(element, current.element)) {
        return i;
      }
      current = current.next; // {5}
    }
    return -1;
  }

  size() {
    return this.count;
  }

  isEmpty() {
    return this.size() === 0;
  }

  getHead() {
    return this.head;
  }

  toString() {
    // 如果链表为空（head 为 null 或 undefined），我们就返回一个空字符串
    if (this.head == null) {
      return "";
    }
    // 链表第一个元素的值来初始化方法最后返回的字符串
    let objString = `${this.head.element}`;
    let current = this.head.next; // {3}
    for (let i = 1; i < this.size() && current != null; i++) {
      objString = `${objString},${current.element}`;
      current = current.next;
    }
    return objString;
  }
}
```
